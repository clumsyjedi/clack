{:rename-macros {}, :renames {}, :use-macros {assert-args cljs.support}, :excludes #{unsafe-bit-and macroexpand unchecked-remainder-int when-first cond->> bit-set gen-class while satisfies? unchecked-subtract-int ns-unmap import bit-shift-right aget pvalues bound-fn specify vswap! dosync caching-hash bit-shift-left coercive-not aclone dec < with-loading-context test this-as .. delay char unchecked-long unchecked-negate simple-benchmark gen-interface unchecked-inc-int with-bindings js-str bit-shift-right-zero-fill implements? goog-define pos? specify! if-not alength bit-xor doseq unsigned-bit-shift-right neg? unchecked-float undefined? deftype mask when-let divide coercive-boolean <= if-some * min with-precision lazy-seq js-delete truth_ defcurried js-debugger let -> defstruct coercive-not= get doto areduce long double definline bit-and-not unchecked-add-int future fn short definterface js-this unchecked-double string? js-arguments unchecked-multiply-int as-> when-not when int > unchecked-int keyword? unchecked-multiply gen-apply-to some->> unchecked-dec defn float js-in ns es6-iterable mod amap declare - hash-set or assert-args extend-type macroexpand-1 bit-test defmethod time zero? unchecked-dec-int memfn js-obj nil? extend-protocol cond-> dotimes bit-and reify instance? with-open load-file* defonce unchecked-add rfn identical? unchecked-divide-int defn- defprotocol unchecked-subtract sync assert true? array letfn / bitpos bit-or vector proxy-super >= loop bit-flip js-mod unchecked-divide with-out-str condp cond with-in-str some-> ns-interns for binding array-map unchecked-byte with-local-vars defmacro unchecked-short alias proxy inc with-redefs bit-clear locking list + var aset destructure defmulti str coercive-= hash-map if-let false? case exists? bit-not io! byte max == lazy-cat comment copy-arguments unsafe-cast defrecord make-array unchecked-negate-int unchecked-inc and number? js-comment symbol? when-some unchecked-char ->> js-inline-comment refer-clojure}, :name cljs.core$macros, :imports nil, :requires {cljs.compiler cljs.compiler, comp cljs.compiler, cljs.core cljs.core, cljs.env cljs.env, ana cljs.analyzer, clojure.set clojure.set, env cljs.env, string clojure.string, cljs.analyzer cljs.analyzer, clojure.string clojure.string, clojure.walk clojure.walk, core cljs.core}, :uses nil, :defs {unsafe-bit-and {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 1124, :column 31, :end-line 1124, :end-column 45, :cljs.analyzer/numeric true, :macro true, :arglists (quote ([x y] [x y & more])), :top-fn {:variadic true, :max-fixed-arity 4, :method-params ([&form &env x y]), :arglists ([&form &env x y] [&form &env x y & more]), :arglists-meta (nil nil)}}, :name cljs.core$macros/unsafe-bit-and, :variadic true, :file "out/cljs/core.cljc", :end-column 45, :top-fn {:variadic true, :max-fixed-arity 4, :method-params ([&form &env x y]), :arglists ([&form &env x y] [&form &env x y & more]), :arglists-meta (nil nil)}, :method-params ([&form &env x y]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1124, :macro true, :end-line 1124, :max-fixed-arity 4, :fn-var true, :arglists ([&form &env x y] [&form &env x y & more]), :cljs.analyzer/numeric true}, macroexpand {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 2732, :column 16, :end-line 2732, :end-column 27, :macro true, :arglists (quote ([quoted])), :doc "Repeatedly calls macroexpand-1 on form until it no longer\n  represents a macro form, then returns it.  Note neither\n  macroexpand-1 nor macroexpand expand macros in subforms."}, :name cljs.core$macros/macroexpand, :variadic false, :file "out/cljs/core.cljc", :end-column 27, :method-params ([&form &env quoted]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2732, :macro true, :end-line 2732, :max-fixed-arity 3, :fn-var true, :arglists (quote ([quoted])), :doc "Repeatedly calls macroexpand-1 on form until it no longer\n  represents a macro form, then returns it.  Note neither\n  macroexpand-1 nor macroexpand expand macros in subforms."}, unchecked-remainder-int {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 1031, :column 31, :end-line 1031, :end-column 54, :cljs.analyzer/numeric true, :macro true, :arglists (quote ([x n]))}, :name cljs.core$macros/unchecked-remainder-int, :variadic false, :file "out/cljs/core.cljc", :end-column 54, :method-params ([&form &env x n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1031, :macro true, :end-line 1031, :max-fixed-arity 4, :fn-var true, :arglists (quote ([x n])), :cljs.analyzer/numeric true}, when-first {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 396, :column 19, :end-line 396, :end-column 29, :macro true, :arglists (quote ([bindings & body])), :doc "bindings => x xs\n\n     Roughly the same as (when (seq xs) (let [x (first xs)] body)) but xs is evaluated only once", :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env bindings body)], :arglists ([&form &env bindings & body]), :arglists-meta (nil)}}, :name cljs.core$macros/when-first, :variadic true, :file "out/cljs/core.cljc", :end-column 29, :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env bindings body)], :arglists ([&form &env bindings & body]), :arglists-meta (nil)}, :method-params [(&form &env bindings body)], :protocol-impl nil, :arglists-meta (nil), :column 4, :line 396, :macro true, :end-line 396, :max-fixed-arity 3, :fn-var true, :arglists ([&form &env bindings & body]), :doc "bindings => x xs\n\n     Roughly the same as (when (seq xs) (let [x (first xs)] body)) but xs is evaluated only once"}, cond->> {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 455, :column 19, :end-line 455, :end-column 26, :macro true, :arglists (quote ([expr & clauses])), :doc "Takes an expression and a set of test/form pairs. Threads expr (via ->>)\n     through each form for which the corresponding test expression\n     is true.  Note that, unlike cond branching, cond->> threading does not short circuit\n     after the first true test expression.", :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env expr clauses)], :arglists ([&form &env expr & clauses]), :arglists-meta (nil)}}, :name cljs.core$macros/cond->>, :variadic true, :file "out/cljs/core.cljc", :end-column 26, :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env expr clauses)], :arglists ([&form &env expr & clauses]), :arglists-meta (nil)}, :method-params [(&form &env expr clauses)], :protocol-impl nil, :arglists-meta (nil), :column 4, :line 455, :macro true, :end-line 455, :max-fixed-arity 3, :fn-var true, :arglists ([&form &env expr & clauses]), :doc "Takes an expression and a set of test/form pairs. Threads expr (via ->>)\n     through each form for which the corresponding test expression\n     is true.  Note that, unlike cond branching, cond->> threading does not short circuit\n     after the first true test expression."}, bit-set {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 1164, :column 31, :end-line 1164, :end-column 38, :cljs.analyzer/numeric true, :macro true, :arglists (quote ([x n]))}, :name cljs.core$macros/bit-set, :variadic false, :file "out/cljs/core.cljc", :end-column 38, :method-params ([&form &env x n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1164, :macro true, :end-line 1164, :max-fixed-arity 4, :fn-var true, :arglists (quote ([x n])), :cljs.analyzer/numeric true}, while {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 431, :column 19, :end-line 431, :end-column 24, :macro true, :arglists (quote ([test & body])), :doc "Repeatedly executes body while test expression is true. Presumes\n     some side-effect will cause test to become false/nil. Returns nil", :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env test body)], :arglists ([&form &env test & body]), :arglists-meta (nil)}}, :name cljs.core$macros/while, :variadic true, :file "out/cljs/core.cljc", :end-column 24, :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env test body)], :arglists ([&form &env test & body]), :arglists-meta (nil)}, :method-params [(&form &env test body)], :protocol-impl nil, :arglists-meta (nil), :column 4, :line 431, :macro true, :end-line 431, :max-fixed-arity 3, :fn-var true, :arglists ([&form &env test & body]), :doc "Repeatedly executes body while test expression is true. Presumes\n     some side-effect will cause test to become false/nil. Returns nil"}, satisfies? {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 2016, :column 16, :end-line 2016, :end-column 26, :macro true, :arglists (quote ([psym x])), :doc "Returns true if x satisfies the protocol"}, :name cljs.core$macros/satisfies?, :variadic false, :file "out/cljs/core.cljc", :end-column 26, :method-params ([&form &env psym x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2016, :macro true, :end-line 2016, :max-fixed-arity 4, :fn-var true, :arglists (quote ([psym x])), :doc "Returns true if x satisfies the protocol"}, protocol-prefix {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 1218, :column 13, :end-line 1218, :end-column 28, :private true, :arglists (quote ([psym]))}, :private true, :name cljs.core$macros/protocol-prefix, :variadic false, :file "out/cljs/core.cljc", :end-column 28, :method-params ([psym]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1218, :end-line 1218, :max-fixed-arity 1, :fn-var true, :arglists (quote ([psym]))}, unchecked-subtract-int {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 1037, :column 31, :end-line 1037, :end-column 53, :cljs.analyzer/numeric true, :macro true, :arglists (quote ([& xs])), :top-fn {:variadic true, :max-fixed-arity 2, :method-params [(&form &env xs)], :arglists ([&form &env & xs]), :arglists-meta (nil)}}, :name cljs.core$macros/unchecked-subtract-int, :variadic true, :file "out/cljs/core.cljc", :end-column 53, :top-fn {:variadic true, :max-fixed-arity 2, :method-params [(&form &env xs)], :arglists ([&form &env & xs]), :arglists-meta (nil)}, :method-params [(&form &env xs)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 1037, :macro true, :end-line 1037, :max-fixed-arity 2, :fn-var true, :arglists ([&form &env & xs]), :cljs.analyzer/numeric true}, ns-unmap {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 2699, :column 16, :end-line 2699, :end-column 24, :macro true, :arglists (quote ([[quote0 ns] [quote1 sym]])), :doc "Removes the mappings for the symbol from the namespace."}, :name cljs.core$macros/ns-unmap, :variadic false, :file "out/cljs/core.cljc", :end-column 24, :method-params ([&form &env p__14651 p__14652]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2699, :macro true, :end-line 2699, :max-fixed-arity 4, :fn-var true, :arglists (quote ([[quote0 ns] [quote1 sym]])), :doc "Removes the mappings for the symbol from the namespace."}, sigs {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 578, :column 3, :end-line 578, :end-column 7, :private true}, :private true, :name cljs.core$macros/sigs, :variadic false, :file "out/cljs/core.cljc", :end-column 7, :method-params ([fdecl]), :protocol-impl nil, :arglists-meta (), :column 1, :line 576, :end-line 578, :max-fixed-arity 1, :fn-var true, :arglists nil}, bool-expr {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 811, :column 13, :end-line 811, :end-column 22, :private true, :arglists (quote ([e]))}, :private true, :name cljs.core$macros/bool-expr, :variadic false, :file "out/cljs/core.cljc", :end-column 22, :method-params ([e]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 811, :end-line 811, :max-fixed-arity 1, :fn-var true, :arglists (quote ([e]))}, adapt-ifn-params {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 1384, :column 13, :end-line 1384, :end-column 29, :private true, :arglists (quote ([type [[this & args :as sig] & body]]))}, :private true, :name cljs.core$macros/adapt-ifn-params, :variadic false, :file "out/cljs/core.cljc", :end-column 29, :method-params ([type p__13938]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1384, :end-line 1384, :max-fixed-arity 2, :fn-var true, :arglists (quote ([type [[this & args :as sig] & body]]))}, bit-shift-right {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 1155, :column 31, :end-line 1155, :end-column 46, :cljs.analyzer/numeric true, :macro true, :arglists (quote ([x n]))}, :name cljs.core$macros/bit-shift-right, :variadic false, :file "out/cljs/core.cljc", :end-column 46, :method-params ([&form &env x n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1155, :macro true, :end-line 1155, :max-fixed-arity 4, :fn-var true, :arglists (quote ([x n])), :cljs.analyzer/numeric true}, aget {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 966, :column 16, :end-line 966, :end-column 20, :macro true, :arglists (quote ([a i] [a i & idxs])), :top-fn {:variadic true, :max-fixed-arity 4, :method-params ([&form &env a i]), :arglists ([&form &env a i] [&form &env a i & idxs]), :arglists-meta (nil nil)}}, :name cljs.core$macros/aget, :variadic true, :file "out/cljs/core.cljc", :end-column 20, :top-fn {:variadic true, :max-fixed-arity 4, :method-params ([&form &env a i]), :arglists ([&form &env a i] [&form &env a i & idxs]), :arglists-meta (nil nil)}, :method-params ([&form &env a i]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 966, :macro true, :end-line 966, :max-fixed-arity 4, :fn-var true, :arglists ([&form &env a i] [&form &env a i & idxs])}, specify {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 1310, :column 16, :end-line 1310, :end-column 23, :macro true, :arglists (quote ([expr & impls])), :doc "Identical to specify! but does not mutate its first argument. The first\n  argument must be an ICloneable instance.", :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env expr impls)], :arglists ([&form &env expr & impls]), :arglists-meta (nil)}}, :name cljs.core$macros/specify, :variadic true, :file "out/cljs/core.cljc", :end-column 23, :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env expr impls)], :arglists ([&form &env expr & impls]), :arglists-meta (nil)}, :method-params [(&form &env expr impls)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 1310, :macro true, :end-line 1310, :max-fixed-arity 3, :fn-var true, :arglists ([&form &env expr & impls]), :doc "Identical to specify! but does not mutate its first argument. The first\n  argument must be an ICloneable instance."}, vswap! {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 2708, :column 16, :end-line 2708, :end-column 22, :macro true, :arglists (quote ([vol f & args])), :doc "Non-atomically swaps the value of the volatile as if:\n   (apply f current-value-of-vol args). Returns the value that\n   was swapped in.", :top-fn {:variadic true, :max-fixed-arity 4, :method-params [(&form &env vol f args)], :arglists ([&form &env vol f & args]), :arglists-meta (nil)}}, :name cljs.core$macros/vswap!, :variadic true, :file "out/cljs/core.cljc", :end-column 22, :top-fn {:variadic true, :max-fixed-arity 4, :method-params [(&form &env vol f args)], :arglists ([&form &env vol f & args]), :arglists-meta (nil)}, :method-params [(&form &env vol f args)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 2708, :macro true, :end-line 2708, :max-fixed-arity 4, :fn-var true, :arglists ([&form &env vol f & args]), :doc "Non-atomically swaps the value of the volatile as if:\n   (apply f current-value-of-vol args). Returns the value that\n   was swapped in."}, type-hint-sigs {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 1525, :column 13, :end-line 1525, :end-column 27, :private true, :arglists (quote ([type-sym sig]))}, :private true, :name cljs.core$macros/type-hint-sigs, :variadic false, :file "out/cljs/core.cljc", :end-column 27, :method-params ([type-sym sig]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1525, :end-line 1525, :max-fixed-arity 2, :fn-var true, :arglists (quote ([type-sym sig]))}, caching-hash {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 1176, :column 16, :end-line 1176, :end-column 28, :macro true, :arglists (quote ([coll hash-fn hash-key]))}, :name cljs.core$macros/caching-hash, :variadic false, :file "out/cljs/core.cljc", :end-column 28, :method-params ([&form &env coll hash-fn hash-key]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1176, :macro true, :end-line 1176, :max-fixed-arity 5, :fn-var true, :arglists (quote ([coll hash-fn hash-key]))}, bit-shift-left {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 1152, :column 31, :end-line 1152, :end-column 45, :cljs.analyzer/numeric true, :macro true, :arglists (quote ([x n]))}, :name cljs.core$macros/bit-shift-left, :variadic false, :file "out/cljs/core.cljc", :end-column 45, :method-params ([&form &env x n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1152, :macro true, :end-line 1152, :max-fixed-arity 4, :fn-var true, :arglists (quote ([x n])), :cljs.analyzer/numeric true}, js-base-type {:name cljs.core$macros/js-base-type, :file "out/cljs/core.cljc", :line 1234, :column 1, :end-line 1234, :end-column 29, :private true, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 1234, :column 17, :end-line 1234, :end-column 29, :private true}}, coercive-not {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 859, :column 16, :end-line 859, :end-column 28, :macro true, :arglists (quote ([x]))}, :name cljs.core$macros/coercive-not, :variadic false, :file "out/cljs/core.cljc", :end-column 28, :method-params ([&form &env x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 859, :macro true, :end-line 859, :max-fixed-arity 3, :fn-var true, :arglists (quote ([x]))}, resolve-var {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 1347, :column 13, :end-line 1347, :end-column 24, :private true, :arglists (quote ([env sym]))}, :private true, :name cljs.core$macros/resolve-var, :variadic false, :file "out/cljs/core.cljc", :end-column 24, :method-params ([env sym]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1347, :end-line 1347, :max-fixed-arity 2, :fn-var true, :arglists (quote ([env sym]))}, dec {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 1086, :column 31, :end-line 1086, :end-column 34, :cljs.analyzer/numeric true, :macro true, :arglists (quote ([x]))}, :name cljs.core$macros/dec, :variadic false, :file "out/cljs/core.cljc", :end-column 34, :method-params ([&form &env x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1086, :macro true, :end-line 1086, :max-fixed-arity 3, :fn-var true, :arglists (quote ([x])), :cljs.analyzer/numeric true}, < {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 1061, :column 31, :end-line 1061, :end-column 32, :cljs.analyzer/numeric true, :macro true, :arglists (quote ([x] [x y] [x y & more])), :top-fn {:variadic true, :max-fixed-arity 4, :method-params ([&form &env x] [&form &env x y]), :arglists ([&form &env x] [&form &env x y] [&form &env x y & more]), :arglists-meta (nil nil nil)}}, :name cljs.core$macros/<, :variadic true, :file "out/cljs/core.cljc", :end-column 32, :top-fn {:variadic true, :max-fixed-arity 4, :method-params ([&form &env x] [&form &env x y]), :arglists ([&form &env x] [&form &env x y] [&form &env x y & more]), :arglists-meta (nil nil nil)}, :method-params ([&form &env x] [&form &env x y]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 1061, :macro true, :end-line 1061, :max-fixed-arity 4, :fn-var true, :arglists ([&form &env x] [&form &env x y] [&form &env x y & more]), :cljs.analyzer/numeric true}, variadic-fn? {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 2749, :column 13, :end-line 2749, :end-column 25, :private true, :arglists (quote ([fdecl]))}, :private true, :name cljs.core$macros/variadic-fn?, :variadic false, :file "out/cljs/core.cljc", :end-column 25, :method-params ([fdecl]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2749, :end-line 2749, :max-fixed-arity 1, :fn-var true, :arglists (quote ([fdecl]))}, this-as {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 1320, :column 16, :end-line 1320, :end-column 23, :macro true, :arglists (quote ([name & body])), :doc "Defines a scope where JavaScript's implicit \"this\" is bound to the name provided.", :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env name body)], :arglists ([&form &env name & body]), :arglists-meta (nil)}}, :name cljs.core$macros/this-as, :variadic true, :file "out/cljs/core.cljc", :end-column 23, :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env name body)], :arglists ([&form &env name & body]), :arglists-meta (nil)}, :method-params [(&form &env name body)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 1320, :macro true, :end-line 1320, :max-fixed-arity 3, :fn-var true, :arglists ([&form &env name & body]), :doc "Defines a scope where JavaScript's implicit \"this\" is bound to the name provided."}, .. {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 133, :column 19, :end-line 133, :end-column 21, :macro true, :arglists (quote ([x form] [x form & more])), :doc "form => fieldName-symbol or (instanceMethodName-symbol args*)\n\n     Expands into a member access (.) of the first member on the first\n     argument, followed by the next member on the result, etc. For\n     instance:\n\n     (.. System (getProperties) (get \"os.name\"))\n\n     expands to:\n\n     (. (. System (getProperties)) (get \"os.name\"))\n\n     but is easier to write, read, and understand.", :top-fn {:variadic true, :max-fixed-arity 4, :method-params ([&form &env x form]), :arglists ([&form &env x form] [&form &env x form & more]), :arglists-meta (nil nil)}}, :name cljs.core$macros/.., :variadic true, :file "out/cljs/core.cljc", :end-column 21, :top-fn {:variadic true, :max-fixed-arity 4, :method-params ([&form &env x form]), :arglists ([&form &env x form] [&form &env x form & more]), :arglists-meta (nil nil)}, :method-params ([&form &env x form]), :protocol-impl nil, :arglists-meta (nil nil), :column 4, :line 133, :macro true, :end-line 133, :max-fixed-arity 4, :fn-var true, :arglists ([&form &env x form] [&form &env x form & more]), :doc "form => fieldName-symbol or (instanceMethodName-symbol args*)\n\n     Expands into a member access (.) of the first member on the first\n     argument, followed by the next member on the result, etc. For\n     instance:\n\n     (.. System (getProperties) (get \"os.name\"))\n\n     expands to:\n\n     (. (. System (getProperties)) (get \"os.name\"))\n\n     but is easier to write, read, and understand."}, delay {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 2054, :column 16, :end-line 2054, :end-column 21, :macro true, :arglists (quote ([& body])), :doc "Takes a body of expressions and yields a Delay object that will\n  invoke the body only the first time it is forced (with force or deref/@), and\n  will cache the result and return it on all subsequent force\n  calls.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params [(&form &env body)], :arglists ([&form &env & body]), :arglists-meta (nil)}}, :name cljs.core$macros/delay, :variadic true, :file "out/cljs/core.cljc", :end-column 21, :top-fn {:variadic true, :max-fixed-arity 2, :method-params [(&form &env body)], :arglists ([&form &env & body]), :arglists-meta (nil)}, :method-params [(&form &env body)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 2054, :macro true, :end-line 2054, :max-fixed-arity 2, :fn-var true, :arglists ([&form &env & body]), :doc "Takes a body of expressions and yields a Delay object that will\n  invoke the body only the first time it is forced (with force or deref/@), and\n  will cache the result and return it on all subsequent force\n  calls."}, unchecked-negate {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 1025, :column 31, :end-line 1025, :end-column 47, :cljs.analyzer/numeric true, :macro true, :arglists (quote ([x]))}, :name cljs.core$macros/unchecked-negate, :variadic false, :file "out/cljs/core.cljc", :end-column 47, :method-params ([&form &env x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1025, :macro true, :end-line 1025, :max-fixed-arity 3, :fn-var true, :arglists (quote ([x])), :cljs.analyzer/numeric true}, simple-benchmark {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 2614, :column 16, :end-line 2614, :end-column 32, :macro true, :arglists (quote ([bindings expr iterations & {:keys [print-fn], :or {print-fn (quote println)}}])), :doc "Runs expr iterations times in the context of a let expression with\n  the given bindings, then prints out the bindings and the expr\n  followed by number of iterations and total time. The optional\n  argument print-fn, defaulting to println, sets function used to\n  print the result. expr's string representation will be produced\n  using pr-str in any case.", :top-fn {:variadic true, :max-fixed-arity 5, :method-params [(&form &env bindings expr iterations {:keys [print-fn], :or {print-fn (quote println)}})], :arglists ([&form &env bindings expr iterations & {:keys [print-fn], :or {print-fn (quote println)}}]), :arglists-meta (nil)}}, :name cljs.core$macros/simple-benchmark, :variadic true, :file "out/cljs/core.cljc", :end-column 32, :top-fn {:variadic true, :max-fixed-arity 5, :method-params [(&form &env bindings expr iterations {:keys [print-fn], :or {print-fn (quote println)}})], :arglists ([&form &env bindings expr iterations & {:keys [print-fn], :or {print-fn (quote println)}}]), :arglists-meta (nil)}, :method-params [(&form &env bindings expr iterations {:keys [print-fn], :or {print-fn (quote println)}})], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 2614, :macro true, :end-line 2614, :max-fixed-arity 5, :fn-var true, :arglists ([&form &env bindings expr iterations & {:keys [print-fn], :or {print-fn (quote println)}}]), :doc "Runs expr iterations times in the context of a let expression with\n  the given bindings, then prints out the bindings and the expr\n  followed by number of iterations and total time. The optional\n  argument print-fn, defaulting to println, sets function used to\n  print the result. expr's string representation will be produced\n  using pr-str in any case."}, prepare-protocol-masks {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 1579, :column 13, :end-line 1579, :end-column 35, :private true, :arglists (quote ([env impls]))}, :private true, :name cljs.core$macros/prepare-protocol-masks, :variadic false, :file "out/cljs/core.cljc", :end-column 35, :method-params ([env impls]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1579, :end-line 1579, :max-fixed-arity 2, :fn-var true, :arglists (quote ([env impls]))}, unchecked-inc-int {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 1016, :column 31, :end-line 1016, :end-column 48, :cljs.analyzer/numeric true, :macro true, :arglists (quote ([x]))}, :name cljs.core$macros/unchecked-inc-int, :variadic false, :file "out/cljs/core.cljc", :end-column 48, :method-params ([&form &env x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1016, :macro true, :end-line 1016, :max-fixed-arity 3, :fn-var true, :arglists (quote ([x])), :cljs.analyzer/numeric true}, js-str {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 2679, :column 16, :end-line 2679, :end-column 22, :macro true, :arglists (quote ([s]))}, :name cljs.core$macros/js-str, :variadic false, :file "out/cljs/core.cljc", :end-column 22, :method-params ([&form &env s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2679, :macro true, :end-line 2679, :max-fixed-arity 3, :fn-var true, :arglists (quote ([s]))}, bit-shift-right-zero-fill {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 1158, :column 31, :end-line 1158, :end-column 56, :cljs.analyzer/numeric true, :macro true, :arglists (quote ([x n]))}, :name cljs.core$macros/bit-shift-right-zero-fill, :variadic false, :file "out/cljs/core.cljc", :end-column 56, :method-params ([&form &env x n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1158, :macro true, :end-line 1158, :max-fixed-arity 4, :fn-var true, :arglists (quote ([x n])), :cljs.analyzer/numeric true}, implements? {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 1990, :column 16, :end-line 1990, :end-column 27, :macro true, :arglists (quote ([psym x])), :doc "EXPERIMENTAL"}, :name cljs.core$macros/implements?, :variadic false, :file "out/cljs/core.cljc", :end-column 27, :method-params ([&form &env psym x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1990, :macro true, :end-line 1990, :max-fixed-arity 4, :fn-var true, :arglists (quote ([psym x])), :doc "EXPERIMENTAL"}, assert-valid-fdecl {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 537, :column 30, :end-line 537, :end-column 48, :dynamic true, :private true, :arglists (quote ([fdecl])), :doc "A good fdecl looks like (([a] ...) ([a b] ...)) near the end of defn."}, :private true, :name cljs.core$macros/assert-valid-fdecl, :variadic false, :file "out/cljs/core.cljc", :end-column 48, :method-params ([fdecl]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :dynamic true, :line 537, :end-line 537, :max-fixed-arity 1, :fn-var true, :arglists (quote ([fdecl])), :doc "A good fdecl looks like (([a] ...) ([a b] ...)) near the end of defn."}, const? {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 2156, :column 13, :end-line 2156, :end-column 19, :private true, :arglists (quote ([env x]))}, :private true, :name cljs.core$macros/const?, :variadic false, :file "out/cljs/core.cljc", :end-column 19, :method-params ([env x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2156, :end-line 2156, :max-fixed-arity 2, :fn-var true, :arglists (quote ([env x]))}, goog-define {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 713, :column 16, :end-line 713, :end-column 27, :macro true, :arglists (quote ([sym default])), :doc "Defines a var using `goog.define`. Passed default value must be\n  string, number or boolean.\n\n  Default value can be overridden at compile time using the\n  compiler option `:closure-defines`.\n\n  Example:\n    (ns your-app.core)\n    (goog-define DEBUG! false)\n    ;; can be overridden with\n    :closure-defines {\"your_app.core.DEBUG_BANG_\" true}\n    or\n    :closure-defines {'your-app.core/DEBUG! true}"}, :name cljs.core$macros/goog-define, :variadic false, :file "out/cljs/core.cljc", :end-column 27, :method-params ([&form &env sym default]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 713, :macro true, :end-line 713, :max-fixed-arity 4, :fn-var true, :arglists (quote ([sym default])), :doc "Defines a var using `goog.define`. Passed default value must be\n  string, number or boolean.\n\n  Default value can be overridden at compile time using the\n  compiler option `:closure-defines`.\n\n  Example:\n    (ns your-app.core)\n    (goog-define DEBUG! false)\n    ;; can be overridden with\n    :closure-defines {\"your_app.core.DEBUG_BANG_\" true}\n    or\n    :closure-defines {'your-app.core/DEBUG! true}"}, pos? {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 1095, :column 31, :end-line 1095, :end-column 35, :cljs.analyzer/numeric true, :macro true, :arglists (quote ([x]))}, :name cljs.core$macros/pos?, :variadic false, :file "out/cljs/core.cljc", :end-column 35, :method-params ([&form &env x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1095, :macro true, :end-line 1095, :max-fixed-arity 3, :fn-var true, :arglists (quote ([x])), :cljs.analyzer/numeric true}, specify! {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 1302, :column 16, :end-line 1302, :end-column 24, :macro true, :arglists (quote ([expr & impls])), :doc "Identical to reify but mutates its first argument.", :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env expr impls)], :arglists ([&form &env expr & impls]), :arglists-meta (nil)}}, :name cljs.core$macros/specify!, :variadic true, :file "out/cljs/core.cljc", :end-column 24, :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env expr impls)], :arglists ([&form &env expr & impls]), :arglists-meta (nil)}, :method-params [(&form &env expr impls)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 1302, :macro true, :end-line 1302, :max-fixed-arity 3, :fn-var true, :arglists ([&form &env expr & impls]), :doc "Identical to reify but mutates its first argument."}, if-not {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 355, :column 19, :end-line 355, :end-column 25, :macro true, :arglists (quote ([test then] [test then else])), :doc "Evaluates test. If logical false, evaluates and returns then expr,\n     otherwise else expr, if supplied, else nil.", :top-fn {:variadic false, :max-fixed-arity 5, :method-params ([&form &env test then] [&form &env test then else]), :arglists ([&form &env test then] [&form &env test then else]), :arglists-meta (nil nil)}}, :name cljs.core$macros/if-not, :variadic false, :file "out/cljs/core.cljc", :end-column 25, :top-fn {:variadic false, :max-fixed-arity 5, :method-params ([&form &env test then] [&form &env test then else]), :arglists ([&form &env test then] [&form &env test then else]), :arglists-meta (nil nil)}, :method-params ([&form &env test then] [&form &env test then else]), :protocol-impl nil, :arglists-meta (nil nil), :column 4, :line 355, :macro true, :end-line 355, :max-fixed-arity 5, :fn-var true, :arglists ([&form &env test then] [&form &env test then else]), :doc "Evaluates test. If logical false, evaluates and returns then expr,\n     otherwise else expr, if supplied, else nil."}, build-positional-factory {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 1629, :column 13, :end-line 1629, :end-column 37, :private true, :arglists (quote ([rsym rname fields]))}, :private true, :name cljs.core$macros/build-positional-factory, :variadic false, :file "out/cljs/core.cljc", :end-column 37, :method-params ([rsym rname fields]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1629, :end-line 1629, :max-fixed-arity 3, :fn-var true, :arglists (quote ([rsym rname fields]))}, alength {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 2498, :column 16, :end-line 2498, :end-column 23, :macro true, :arglists (quote ([a]))}, :name cljs.core$macros/alength, :variadic false, :file "out/cljs/core.cljc", :end-column 23, :method-params ([&form &env a]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2498, :macro true, :end-line 2498, :max-fixed-arity 3, :fn-var true, :arglists (quote ([a]))}, bit-xor {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 1135, :column 31, :end-line 1135, :end-column 38, :cljs.analyzer/numeric true, :macro true, :arglists (quote ([x y] [x y & more])), :top-fn {:variadic true, :max-fixed-arity 4, :method-params ([&form &env x y]), :arglists ([&form &env x y] [&form &env x y & more]), :arglists-meta (nil nil)}}, :name cljs.core$macros/bit-xor, :variadic true, :file "out/cljs/core.cljc", :end-column 38, :top-fn {:variadic true, :max-fixed-arity 4, :method-params ([&form &env x y]), :arglists ([&form &env x y] [&form &env x y & more]), :arglists-meta (nil nil)}, :method-params ([&form &env x y]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1135, :macro true, :end-line 1135, :max-fixed-arity 4, :fn-var true, :arglists ([&form &env x y] [&form &env x y & more]), :cljs.analyzer/numeric true}, doseq {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 2332, :column 16, :end-line 2332, :end-column 21, :macro true, :arglists (quote ([seq-exprs & body])), :doc "Repeatedly executes body (presumably for side-effects) with\n  bindings and filtering as provided by \"for\".  Does not retain\n  the head of the sequence. Returns nil.", :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env seq-exprs body)], :arglists ([&form &env seq-exprs & body]), :arglists-meta (nil)}}, :name cljs.core$macros/doseq, :variadic true, :file "out/cljs/core.cljc", :end-column 21, :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env seq-exprs body)], :arglists ([&form &env seq-exprs & body]), :arglists-meta (nil)}, :method-params [(&form &env seq-exprs body)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 2332, :macro true, :end-line 2332, :max-fixed-arity 3, :fn-var true, :arglists ([&form &env seq-exprs & body]), :doc "Repeatedly executes body (presumably for side-effects) with\n  bindings and filtering as provided by \"for\".  Does not retain\n  the head of the sequence. Returns nil."}, unsigned-bit-shift-right {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 1161, :column 31, :end-line 1161, :end-column 55, :cljs.analyzer/numeric true, :macro true, :arglists (quote ([x n]))}, :name cljs.core$macros/unsigned-bit-shift-right, :variadic false, :file "out/cljs/core.cljc", :end-column 55, :method-params ([&form &env x n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1161, :macro true, :end-line 1161, :max-fixed-arity 4, :fn-var true, :arglists (quote ([x n])), :cljs.analyzer/numeric true}, neg? {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 1098, :column 31, :end-line 1098, :end-column 35, :cljs.analyzer/numeric true, :macro true, :arglists (quote ([x]))}, :name cljs.core$macros/neg?, :variadic false, :file "out/cljs/core.cljc", :end-column 35, :method-params ([&form &env x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1098, :macro true, :end-line 1098, :max-fixed-arity 3, :fn-var true, :arglists (quote ([x])), :cljs.analyzer/numeric true}, adapt-ifn-invoke-params {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 1392, :column 13, :end-line 1392, :end-column 36, :private true, :arglists (quote ([type [[this & args :as sig] & body]]))}, :private true, :name cljs.core$macros/adapt-ifn-invoke-params, :variadic false, :file "out/cljs/core.cljc", :end-column 36, :method-params ([type p__13951]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1392, :end-line 1392, :max-fixed-arity 2, :fn-var true, :arglists (quote ([type [[this & args :as sig] & body]]))}, unchecked-float {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 995, :column 16, :end-line 995, :end-column 31, :macro true, :arglists (quote ([x]))}, :name cljs.core$macros/unchecked-float, :variadic false, :file "out/cljs/core.cljc", :end-column 31, :method-params ([&form &env x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 995, :macro true, :end-line 995, :max-fixed-arity 3, :fn-var true, :arglists (quote ([x]))}, undefined? {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 940, :column 16, :end-line 940, :end-column 26, :macro true, :arglists (quote ([x])), :doc "Return true if argument is identical to the JavaScript undefined value."}, :name cljs.core$macros/undefined?, :variadic false, :file "out/cljs/core.cljc", :end-column 26, :method-params ([&form &env x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 940, :macro true, :end-line 940, :max-fixed-arity 3, :fn-var true, :arglists (quote ([x])), :doc "Return true if argument is identical to the JavaScript undefined value."}, deftype {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 1645, :column 16, :end-line 1645, :end-column 23, :macro true, :arglists (quote ([t fields & impls])), :doc "(deftype name [fields*]  options* specs*)\n\n  Currently there are no options.\n\n  Each spec consists of a protocol or interface name followed by zero\n  or more method bodies:\n\n  protocol-or-Object\n  (methodName [args*] body)*\n\n  The type will have the (by default, immutable) fields named by\n  fields, which can have type hints. Protocols and methods\n  are optional. The only methods that can be supplied are those\n  declared in the protocols/interfaces.  Note that method bodies are\n  not closures, the local environment includes only the named fields,\n  and those fields can be accessed directly. Fields can be qualified\n  with the metadata :mutable true at which point (set! afield aval) will be\n  supported in method bodies. Note well that mutable fields are extremely\n  difficult to use correctly, and are present only to facilitate the building\n  of higherlevel constructs, such as ClojureScript's reference types, in\n  ClojureScript itself. They are for experts only - if the semantics and\n  implications of :mutable are not immediately apparent to you, you should not\n  be using them.\n\n  Method definitions take the form:\n\n  (methodname [args*] body)\n\n  The argument and return types can be hinted on the arg and\n  methodname symbols. If not supplied, they will be inferred, so type\n  hints should be reserved for disambiguation.\n\n  Methods should be supplied for all methods of the desired\n  protocol(s). You can also define overrides for methods of Object. Note that\n  a parameter must be supplied to correspond to the target object\n  ('this' in JavaScript parlance). Note also that recur calls to the method\n  head should *not* pass the target object, it will be supplied\n  automatically and can not be substituted.\n\n  In the method bodies, the (unqualified) name can be used to name the\n  class (for calls to new, instance? etc).\n\n  One constructor will be defined, taking the designated fields.  Note\n  that the field names __meta and __extmap are currently reserved and\n  should not be used when defining your own types.\n\n  Given (deftype TypeName ...), a factory function called ->TypeName\n  will be defined, taking positional parameters for the fields", :top-fn {:variadic true, :max-fixed-arity 4, :method-params [(&form &env t fields impls)], :arglists ([&form &env t fields & impls]), :arglists-meta (nil)}}, :name cljs.core$macros/deftype, :variadic true, :file "out/cljs/core.cljc", :end-column 23, :top-fn {:variadic true, :max-fixed-arity 4, :method-params [(&form &env t fields impls)], :arglists ([&form &env t fields & impls]), :arglists-meta (nil)}, :method-params [(&form &env t fields impls)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 1645, :macro true, :end-line 1645, :max-fixed-arity 4, :fn-var true, :arglists ([&form &env t fields & impls]), :doc "(deftype name [fields*]  options* specs*)\n\n  Currently there are no options.\n\n  Each spec consists of a protocol or interface name followed by zero\n  or more method bodies:\n\n  protocol-or-Object\n  (methodName [args*] body)*\n\n  The type will have the (by default, immutable) fields named by\n  fields, which can have type hints. Protocols and methods\n  are optional. The only methods that can be supplied are those\n  declared in the protocols/interfaces.  Note that method bodies are\n  not closures, the local environment includes only the named fields,\n  and those fields can be accessed directly. Fields can be qualified\n  with the metadata :mutable true at which point (set! afield aval) will be\n  supported in method bodies. Note well that mutable fields are extremely\n  difficult to use correctly, and are present only to facilitate the building\n  of higherlevel constructs, such as ClojureScript's reference types, in\n  ClojureScript itself. They are for experts only - if the semantics and\n  implications of :mutable are not immediately apparent to you, you should not\n  be using them.\n\n  Method definitions take the form:\n\n  (methodname [args*] body)\n\n  The argument and return types can be hinted on the arg and\n  methodname symbols. If not supplied, they will be inferred, so type\n  hints should be reserved for disambiguation.\n\n  Methods should be supplied for all methods of the desired\n  protocol(s). You can also define overrides for methods of Object. Note that\n  a parameter must be supplied to correspond to the target object\n  ('this' in JavaScript parlance). Note also that recur calls to the method\n  head should *not* pass the target object, it will be supplied\n  automatically and can not be substituted.\n\n  In the method bodies, the (unqualified) name can be used to name the\n  class (for calls to new, instance? etc).\n\n  One constructor will be defined, taking the designated fields.  Note\n  that the field names __meta and __extmap are currently reserved and\n  should not be used when defining your own types.\n\n  Given (deftype TypeName ...), a factory function called ->TypeName\n  will be defined, taking positional parameters for the fields"}, mask {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 1168, :column 16, :end-line 1168, :end-column 20, :macro true, :arglists (quote ([hash shift]))}, :name cljs.core$macros/mask, :variadic false, :file "out/cljs/core.cljc", :end-column 20, :method-params ([&form &env hash shift]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1168, :macro true, :end-line 1168, :max-fixed-arity 4, :fn-var true, :arglists (quote ([hash shift]))}, build-map-factory {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 1800, :column 13, :end-line 1800, :end-column 30, :private true, :arglists (quote ([rsym rname fields]))}, :private true, :name cljs.core$macros/build-map-factory, :variadic false, :file "out/cljs/core.cljc", :end-column 30, :method-params ([rsym rname fields]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1800, :end-line 1800, :max-fixed-arity 3, :fn-var true, :arglists (quote ([rsym rname fields]))}, when-let {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 410, :column 19, :end-line 410, :end-column 27, :macro true, :arglists (quote ([bindings & body])), :doc "bindings => binding-form test\n\n     When test is true, evaluates body with binding-form bound to the value of test", :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env bindings body)], :arglists ([&form &env bindings & body]), :arglists-meta (nil)}}, :name cljs.core$macros/when-let, :variadic true, :file "out/cljs/core.cljc", :end-column 27, :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env bindings body)], :arglists ([&form &env bindings & body]), :arglists-meta (nil)}, :method-params [(&form &env bindings body)], :protocol-impl nil, :arglists-meta (nil), :column 4, :line 410, :macro true, :end-line 410, :max-fixed-arity 3, :fn-var true, :arglists ([&form &env bindings & body]), :doc "bindings => binding-form test\n\n     When test is true, evaluates body with binding-form bound to the value of test"}, divide {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 1056, :column 31, :end-line 1056, :end-column 37, :cljs.analyzer/numeric true, :macro true, :arglists (quote ([x] [x y] [x y & more])), :top-fn {:variadic true, :max-fixed-arity 4, :method-params ([&form &env x] [&form &env x y]), :arglists ([&form &env x] [&form &env x y] [&form &env x y & more]), :arglists-meta (nil nil nil)}}, :name cljs.core$macros/divide, :variadic true, :file "out/cljs/core.cljc", :end-column 37, :top-fn {:variadic true, :max-fixed-arity 4, :method-params ([&form &env x] [&form &env x y]), :arglists ([&form &env x] [&form &env x y] [&form &env x y & more]), :arglists-meta (nil nil nil)}, :method-params ([&form &env x] [&form &env x y]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 1056, :macro true, :end-line 1056, :max-fixed-arity 4, :fn-var true, :arglists ([&form &env x] [&form &env x y] [&form &env x y & more]), :cljs.analyzer/numeric true}, coercive-boolean {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 871, :column 16, :end-line 871, :end-column 32, :macro true, :arglists (quote ([x]))}, :name cljs.core$macros/coercive-boolean, :variadic false, :file "out/cljs/core.cljc", :end-column 32, :method-params ([&form &env x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 871, :macro true, :end-line 871, :max-fixed-arity 3, :fn-var true, :arglists (quote ([x]))}, <= {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 1066, :column 31, :end-line 1066, :end-column 33, :cljs.analyzer/numeric true, :macro true, :arglists (quote ([x] [x y] [x y & more])), :top-fn {:variadic true, :max-fixed-arity 4, :method-params ([&form &env x] [&form &env x y]), :arglists ([&form &env x] [&form &env x y] [&form &env x y & more]), :arglists-meta (nil nil nil)}}, :name cljs.core$macros/<=, :variadic true, :file "out/cljs/core.cljc", :end-column 33, :top-fn {:variadic true, :max-fixed-arity 4, :method-params ([&form &env x] [&form &env x y]), :arglists ([&form &env x] [&form &env x y] [&form &env x y & more]), :arglists-meta (nil nil nil)}, :method-params ([&form &env x] [&form &env x y]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 1066, :macro true, :end-line 1066, :max-fixed-arity 4, :fn-var true, :arglists ([&form &env x] [&form &env x y] [&form &env x y & more]), :cljs.analyzer/numeric true}, if-some {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 501, :column 19, :end-line 501, :end-column 26, :macro true, :arglists (quote ([bindings then] [bindings then else & oldform])), :doc "bindings => binding-form test\n\n      If test is not nil, evaluates then with binding-form bound to the\n      value of test, if not, yields else", :top-fn {:variadic true, :max-fixed-arity 5, :method-params ([&form &env bindings then]), :arglists ([&form &env bindings then] [&form &env bindings then else & oldform]), :arglists-meta (nil nil)}}, :name cljs.core$macros/if-some, :variadic true, :file "out/cljs/core.cljc", :end-column 26, :top-fn {:variadic true, :max-fixed-arity 5, :method-params ([&form &env bindings then]), :arglists ([&form &env bindings then] [&form &env bindings then else & oldform]), :arglists-meta (nil nil)}, :method-params ([&form &env bindings then]), :protocol-impl nil, :arglists-meta (nil nil), :column 4, :line 501, :macro true, :end-line 501, :max-fixed-arity 5, :fn-var true, :arglists ([&form &env bindings then] [&form &env bindings then else & oldform]), :doc "bindings => binding-form test\n\n      If test is not nil, evaluates then with binding-form bound to the\n      value of test, if not, yields else"}, * {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 1045, :column 31, :end-line 1045, :end-column 32, :cljs.analyzer/numeric true, :macro true, :arglists (quote ([] [x] [x y] [x y & more])), :top-fn {:variadic true, :max-fixed-arity 4, :method-params ([&form &env] [&form &env x] [&form &env x y]), :arglists ([&form &env] [&form &env x] [&form &env x y] [&form &env x y & more]), :arglists-meta (nil nil nil nil)}}, :name cljs.core$macros/*, :variadic true, :file "out/cljs/core.cljc", :end-column 32, :top-fn {:variadic true, :max-fixed-arity 4, :method-params ([&form &env] [&form &env x] [&form &env x y]), :arglists ([&form &env] [&form &env x] [&form &env x y] [&form &env x y & more]), :arglists-meta (nil nil nil nil)}, :method-params ([&form &env] [&form &env x] [&form &env x y]), :protocol-impl nil, :arglists-meta (nil nil nil nil), :column 1, :line 1045, :macro true, :end-line 1045, :max-fixed-arity 4, :fn-var true, :arglists ([&form &env] [&form &env x] [&form &env x y] [&form &env x y & more]), :cljs.analyzer/numeric true}, min {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 1107, :column 31, :end-line 1107, :end-column 34, :cljs.analyzer/numeric true, :macro true, :arglists (quote ([x] [x y] [x y & more])), :top-fn {:variadic true, :max-fixed-arity 4, :method-params ([&form &env x] [&form &env x y]), :arglists ([&form &env x] [&form &env x y] [&form &env x y & more]), :arglists-meta (nil nil nil)}}, :name cljs.core$macros/min, :variadic true, :file "out/cljs/core.cljc", :end-column 34, :top-fn {:variadic true, :max-fixed-arity 4, :method-params ([&form &env x] [&form &env x y]), :arglists ([&form &env x] [&form &env x y] [&form &env x y & more]), :arglists-meta (nil nil nil)}, :method-params ([&form &env x] [&form &env x y]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 1107, :macro true, :end-line 1107, :max-fixed-arity 4, :fn-var true, :arglists ([&form &env x] [&form &env x y] [&form &env x y & more]), :cljs.analyzer/numeric true}, adapt-proto-params {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 1397, :column 13, :end-line 1397, :end-column 31, :private true, :arglists (quote ([type [[this & args :as sig] & body]]))}, :private true, :name cljs.core$macros/adapt-proto-params, :variadic false, :file "out/cljs/core.cljc", :end-column 31, :method-params ([type p__13964]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1397, :end-line 1397, :max-fixed-arity 2, :fn-var true, :arglists (quote ([type [[this & args :as sig] & body]]))}, lazy-seq {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 2046, :column 16, :end-line 2046, :end-column 24, :macro true, :arglists (quote ([& body])), :doc "Takes a body of expressions that returns an ISeq or nil, and yields\n  a ISeqable object that will invoke the body only the first time seq\n  is called, and will cache the result and return it on all subsequent\n  seq calls.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params [(&form &env body)], :arglists ([&form &env & body]), :arglists-meta (nil)}}, :name cljs.core$macros/lazy-seq, :variadic true, :file "out/cljs/core.cljc", :end-column 24, :top-fn {:variadic true, :max-fixed-arity 2, :method-params [(&form &env body)], :arglists ([&form &env & body]), :arglists-meta (nil)}, :method-params [(&form &env body)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 2046, :macro true, :end-line 2046, :max-fixed-arity 2, :fn-var true, :arglists ([&form &env & body]), :doc "Takes a body of expressions that returns an ISeq or nil, and yields\n  a ISeqable object that will invoke the body only the first time seq\n  is called, and will cache the result and return it on all subsequent\n  seq calls."}, js-delete {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 884, :column 16, :end-line 884, :end-column 25, :macro true, :arglists (quote ([obj key]))}, :name cljs.core$macros/js-delete, :variadic false, :file "out/cljs/core.cljc", :end-column 25, :method-params ([&form &env obj key]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 884, :macro true, :end-line 884, :max-fixed-arity 4, :fn-var true, :arglists (quote ([obj key]))}, truth_ {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 876, :column 16, :end-line 876, :end-column 22, :macro true, :arglists (quote ([x]))}, :name cljs.core$macros/truth_, :variadic false, :file "out/cljs/core.cljc", :end-column 22, :method-params ([&form &env x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 876, :macro true, :end-line 876, :max-fixed-arity 3, :fn-var true, :arglists (quote ([x]))}, annotate-specs {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 1601, :column 13, :end-line 1601, :end-column 27, :private true, :arglists (quote ([annots v [f sigs]]))}, :private true, :name cljs.core$macros/annotate-specs, :variadic false, :file "out/cljs/core.cljc", :end-column 27, :method-params ([annots v p__14066]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1601, :end-line 1601, :max-fixed-arity 3, :fn-var true, :arglists (quote ([annots v [f sigs]]))}, defcurried {:protocol-inline nil, :meta {:private true, :file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :end-column 36, :top-fn {:variadic true, :max-fixed-arity 6, :method-params [(&form &env name doc meta args body)], :arglists ([&form &env name doc meta args & body]), :arglists-meta (nil)}, :column 26, :line 1194, :macro true, :end-line 1194, :arglists (quote ([name doc meta args & body])), :doc "Builds another arity of the fn that returns a fn awaiting the last\n  param"}, :private true, :name cljs.core$macros/defcurried, :variadic true, :file "out/cljs/core.cljc", :end-column 36, :top-fn {:variadic true, :max-fixed-arity 6, :method-params [(&form &env name doc meta args body)], :arglists ([&form &env name doc meta args & body]), :arglists-meta (nil)}, :method-params [(&form &env name doc meta args body)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 1194, :macro true, :end-line 1194, :max-fixed-arity 6, :fn-var true, :arglists ([&form &env name doc meta args & body]), :doc "Builds another arity of the fn that returns a fn awaiting the last\n  param"}, js-debugger {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 890, :column 16, :end-line 890, :end-column 27, :macro true, :arglists (quote ([])), :doc "Emit JavaScript \"debugger;\" statement"}, :name cljs.core$macros/js-debugger, :variadic false, :file "out/cljs/core.cljc", :end-column 27, :method-params ([&form &env]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 890, :macro true, :end-line 890, :max-fixed-arity 2, :fn-var true, :arglists (quote ([])), :doc "Emit JavaScript \"debugger;\" statement"}, let {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 743, :column 16, :end-line 743, :end-column 19, :macro true, :arglists (quote ([bindings & body])), :doc "binding => binding-form init-expr\n\n  Evaluates the exprs in a lexical context in which the symbols in\n  the binding-forms are bound to their respective init-exprs or parts\n  therein.", :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env bindings body)], :arglists ([&form &env bindings & body]), :arglists-meta (nil)}}, :name cljs.core$macros/let, :variadic true, :file "out/cljs/core.cljc", :end-column 19, :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env bindings body)], :arglists ([&form &env bindings & body]), :arglists-meta (nil)}, :method-params [(&form &env bindings body)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 743, :macro true, :end-line 743, :max-fixed-arity 3, :fn-var true, :arglists ([&form &env bindings & body]), :doc "binding => binding-form init-expr\n\n  Evaluates the exprs in a lexical context in which the symbols in\n  the binding-forms are bound to their respective init-exprs or parts\n  therein."}, base-type {:name cljs.core$macros/base-type, :file "out/cljs/core.cljc", :line 1224, :column 1, :end-line 1224, :end-column 26, :private true, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 1224, :column 17, :end-line 1224, :end-column 26, :private true}}, -> {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 101, :column 19, :end-line 101, :end-column 21, :macro true, :arglists (quote ([x & forms])), :doc "Threads the expr through the forms. Inserts x as the\n     second item in the first form, making a list of it if it is not a\n     list already. If there are more forms, inserts the first form as the\n     second item in second form, etc.", :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env x forms)], :arglists ([&form &env x & forms]), :arglists-meta (nil)}}, :name cljs.core$macros/->, :variadic true, :file "out/cljs/core.cljc", :end-column 21, :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env x forms)], :arglists ([&form &env x & forms]), :arglists-meta (nil)}, :method-params [(&form &env x forms)], :protocol-impl nil, :arglists-meta (nil), :column 4, :line 101, :macro true, :end-line 101, :max-fixed-arity 3, :fn-var true, :arglists ([&form &env x & forms]), :doc "Threads the expr through the forms. Inserts x as the\n     second item in the first form, making a list of it if it is not a\n     list already. If there are more forms, inserts the first form as the\n     second item in second form, etc."}, coercive-not= {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 863, :column 16, :end-line 863, :end-column 29, :macro true, :arglists (quote ([x y]))}, :name cljs.core$macros/coercive-not=, :variadic false, :file "out/cljs/core.cljc", :end-column 29, :method-params ([&form &env x y]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 863, :macro true, :end-line 863, :max-fixed-arity 4, :fn-var true, :arglists (quote ([x y]))}, doto {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 176, :column 19, :end-line 176, :end-column 23, :macro true, :arglists (quote ([x & forms])), :doc "Evaluates x then calls all of the methods and functions with the\n     value of x supplied at the front of the given arguments.  The forms\n     are evaluated in order.  Returns x.\n\n     (doto (new java.util.HashMap) (.put \"a\" 1) (.put \"b\" 2))", :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env x forms)], :arglists ([&form &env x & forms]), :arglists-meta (nil)}}, :name cljs.core$macros/doto, :variadic true, :file "out/cljs/core.cljc", :end-column 23, :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env x forms)], :arglists ([&form &env x & forms]), :arglists-meta (nil)}, :method-params [(&form &env x forms)], :protocol-impl nil, :arglists-meta (nil), :column 4, :line 176, :macro true, :end-line 176, :max-fixed-arity 3, :fn-var true, :arglists ([&form &env x & forms]), :doc "Evaluates x then calls all of the methods and functions with the\n     value of x supplied at the front of the given arguments.  The forms\n     are evaluated in order.  Returns x.\n\n     (doto (new java.util.HashMap) (.put \"a\" 1) (.put \"b\" 2))"}, areduce {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 2518, :column 16, :end-line 2518, :end-column 23, :macro true, :arglists (quote ([a idx ret init expr])), :doc "Reduces an expression across an array a, using an index named idx,\n  and return value named ret, initialized to init, setting ret to the\n  evaluation of expr at each step, returning ret."}, :name cljs.core$macros/areduce, :variadic false, :file "out/cljs/core.cljc", :end-column 23, :method-params ([&form &env a idx ret init expr]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2518, :macro true, :end-line 2518, :max-fixed-arity 7, :fn-var true, :arglists (quote ([a idx ret init expr])), :doc "Reduces an expression across an array a, using an index named idx,\n  and return value named ret, initialized to init, setting ret to the\n  evaluation of expr at each step, returning ret."}, double {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 990, :column 16, :end-line 990, :end-column 22, :macro true, :arglists (quote ([x]))}, :name cljs.core$macros/double, :variadic false, :file "out/cljs/core.cljc", :end-column 22, :method-params ([&form &env x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 990, :macro true, :end-line 990, :max-fixed-arity 3, :fn-var true, :arglists (quote ([x]))}, emit-extend-protocol {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 201, :column 16, :end-line 201, :end-column 36, :private true, :arglists (quote ([p specs]))}, :private true, :name cljs.core$macros/emit-extend-protocol, :variadic false, :file "out/cljs/core.cljc", :end-column 36, :method-params ([p specs]), :protocol-impl nil, :arglists-meta (nil nil), :column 4, :line 201, :end-line 201, :max-fixed-arity 2, :fn-var true, :arglists (quote ([p specs]))}, bit-and-not {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 1139, :column 31, :end-line 1139, :end-column 42, :cljs.analyzer/numeric true, :macro true, :arglists (quote ([x y] [x y & more])), :top-fn {:variadic true, :max-fixed-arity 4, :method-params ([&form &env x y]), :arglists ([&form &env x y] [&form &env x y & more]), :arglists-meta (nil nil)}}, :name cljs.core$macros/bit-and-not, :variadic true, :file "out/cljs/core.cljc", :end-column 42, :top-fn {:variadic true, :max-fixed-arity 4, :method-params ([&form &env x y]), :arglists ([&form &env x y] [&form &env x y & more]), :arglists-meta (nil nil)}, :method-params ([&form &env x y]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1139, :macro true, :end-line 1139, :max-fixed-arity 4, :fn-var true, :arglists ([&form &env x y] [&form &env x y & more]), :cljs.analyzer/numeric true}, unchecked-add-int {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 1001, :column 31, :end-line 1001, :end-column 48, :cljs.analyzer/numeric true, :macro true, :arglists (quote ([& xs])), :top-fn {:variadic true, :max-fixed-arity 2, :method-params [(&form &env xs)], :arglists ([&form &env & xs]), :arglists-meta (nil)}}, :name cljs.core$macros/unchecked-add-int, :variadic true, :file "out/cljs/core.cljc", :end-column 48, :top-fn {:variadic true, :max-fixed-arity 2, :method-params [(&form &env xs)], :arglists ([&form &env & xs]), :arglists-meta (nil)}, :method-params [(&form &env xs)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 1001, :macro true, :end-line 1001, :max-fixed-arity 2, :fn-var true, :arglists ([&form &env & xs]), :cljs.analyzer/numeric true}, do-rfn {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 1200, :column 13, :end-line 1200, :end-column 19, :private true, :arglists (quote ([f1 k fkv]))}, :private true, :name cljs.core$macros/do-rfn, :variadic false, :file "out/cljs/core.cljc", :end-column 19, :method-params ([f1 k fkv]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1200, :end-line 1200, :max-fixed-arity 3, :fn-var true, :arglists (quote ([f1 k fkv]))}, fn {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :end-column 21, :top-fn {:variadic true, :max-fixed-arity 2, :method-params [(&form &env sigs)], :arglists ([&form &env & sigs]), :arglists-meta (nil)}, :column 19, :line 267, :macro true, :end-line 267, :arglists (quote ([& sigs])), :doc "params => positional-params* , or positional-params* & next-param\n     positional-param => binding-form\n     next-param => binding-form\n     name => symbol\n\n     Defines a function", :forms (quote [(fn name? [params*] exprs*) (fn name? ([params*] exprs*) +)])}, :name cljs.core$macros/fn, :variadic true, :file "out/cljs/core.cljc", :end-column 21, :top-fn {:variadic true, :max-fixed-arity 2, :method-params [(&form &env sigs)], :arglists ([&form &env & sigs]), :arglists-meta (nil)}, :method-params [(&form &env sigs)], :protocol-impl nil, :arglists-meta (nil), :column 4, :line 267, :macro true, :end-line 267, :max-fixed-arity 2, :fn-var true, :arglists ([&form &env & sigs]), :doc "params => positional-params* , or positional-params* & next-param\n     positional-param => binding-form\n     next-param => binding-form\n     name => symbol\n\n     Defines a function", :forms (quote [(fn name? [params*] exprs*) (fn name? ([params*] exprs*) +)])}, short {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 988, :column 16, :end-line 988, :end-column 21, :macro true, :arglists (quote ([x]))}, :name cljs.core$macros/short, :variadic false, :file "out/cljs/core.cljc", :end-column 21, :method-params ([&form &env x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 988, :macro true, :end-line 988, :max-fixed-arity 3, :fn-var true, :arglists (quote ([x]))}, js-this {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 1317, :column 26, :end-line 1317, :end-column 33, :private true, :macro true, :arglists (quote ([]))}, :private true, :name cljs.core$macros/js-this, :variadic false, :file "out/cljs/core.cljc", :end-column 33, :method-params ([&form &env]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1317, :macro true, :end-line 1317, :max-fixed-arity 2, :fn-var true, :arglists (quote ([]))}, unchecked-double {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 996, :column 16, :end-line 996, :end-column 32, :macro true, :arglists (quote ([x]))}, :name cljs.core$macros/unchecked-double, :variadic false, :file "out/cljs/core.cljc", :end-column 32, :method-params ([&form &env x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 996, :macro true, :end-line 996, :max-fixed-arity 3, :fn-var true, :arglists (quote ([x]))}, fast-path-protocols {:name cljs.core$macros/fast-path-protocols, :file "out/cljs/core.cljc", :line 779, :column 1, :end-line 779, :end-column 25, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 779, :column 6, :end-line 779, :end-column 25}, :doc "protocol fqn -> [partition number, bit]"}, string? {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 928, :column 16, :end-line 928, :end-column 23, :macro true, :arglists (quote ([x]))}, :name cljs.core$macros/string?, :variadic false, :file "out/cljs/core.cljc", :end-column 23, :method-params ([&form &env x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 928, :macro true, :end-line 928, :max-fixed-arity 3, :fn-var true, :arglists (quote ([x]))}, emit-defrecord {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 1715, :column 13, :end-line 1715, :end-column 27, :private true, :arglists (quote ([env tagname rname fields impls])), :doc "Do not use this directly - use defrecord"}, :private true, :name cljs.core$macros/emit-defrecord, :variadic false, :file "out/cljs/core.cljc", :end-column 27, :method-params ([env tagname rname fields impls]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1715, :end-line 1715, :max-fixed-arity 5, :fn-var true, :arglists (quote ([env tagname rname fields impls])), :doc "Do not use this directly - use defrecord"}, validate-impl-sigs {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 1463, :column 13, :end-line 1463, :end-column 31, :private true, :arglists (quote ([env p method]))}, :private true, :name cljs.core$macros/validate-impl-sigs, :variadic false, :file "out/cljs/core.cljc", :end-column 31, :method-params ([env p method]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1463, :end-line 1463, :max-fixed-arity 3, :fn-var true, :arglists (quote ([env p method]))}, js-arguments {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 881, :column 16, :end-line 881, :end-column 28, :macro true, :arglists (quote ([]))}, :name cljs.core$macros/js-arguments, :variadic false, :file "out/cljs/core.cljc", :end-column 28, :method-params ([&form &env]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 881, :macro true, :end-line 881, :max-fixed-arity 2, :fn-var true, :arglists (quote ([]))}, unchecked-multiply-int {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 1022, :column 31, :end-line 1022, :end-column 53, :cljs.analyzer/numeric true, :macro true, :arglists (quote ([& xs])), :top-fn {:variadic true, :max-fixed-arity 2, :method-params [(&form &env xs)], :arglists ([&form &env & xs]), :arglists-meta (nil)}}, :name cljs.core$macros/unchecked-multiply-int, :variadic true, :file "out/cljs/core.cljc", :end-column 53, :top-fn {:variadic true, :max-fixed-arity 2, :method-params [(&form &env xs)], :arglists ([&form &env & xs]), :arglists-meta (nil)}, :method-params [(&form &env xs)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 1022, :macro true, :end-line 1022, :max-fixed-arity 2, :fn-var true, :arglists ([&form &env & xs]), :cljs.analyzer/numeric true}, as-> {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 469, :column 19, :end-line 469, :end-column 23, :macro true, :arglists (quote ([expr name & forms])), :doc "Binds name to expr, evaluates the first form in the lexical context\n     of that binding, then binds name to that result, repeating for each\n     successive form, returning the result of the last form.", :top-fn {:variadic true, :max-fixed-arity 4, :method-params [(&form &env expr name forms)], :arglists ([&form &env expr name & forms]), :arglists-meta (nil)}}, :name cljs.core$macros/as->, :variadic true, :file "out/cljs/core.cljc", :end-column 23, :top-fn {:variadic true, :max-fixed-arity 4, :method-params [(&form &env expr name forms)], :arglists ([&form &env expr name & forms]), :arglists-meta (nil)}, :method-params [(&form &env expr name forms)], :protocol-impl nil, :arglists-meta (nil), :column 4, :line 469, :macro true, :end-line 469, :max-fixed-arity 4, :fn-var true, :arglists ([&form &env expr name & forms]), :doc "Binds name to expr, evaluates the first form in the lexical context\n     of that binding, then binds name to that result, repeating for each\n     successive form, returning the result of the last form."}, when-not {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 425, :column 19, :end-line 425, :end-column 27, :macro true, :arglists (quote ([test & body])), :doc "Evaluates test. If logical false, evaluates body in an implicit do.", :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env test body)], :arglists ([&form &env test & body]), :arglists-meta (nil)}}, :name cljs.core$macros/when-not, :variadic true, :file "out/cljs/core.cljc", :end-column 27, :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env test body)], :arglists ([&form &env test & body]), :arglists-meta (nil)}, :method-params [(&form &env test body)], :protocol-impl nil, :arglists-meta (nil), :column 4, :line 425, :macro true, :end-line 425, :max-fixed-arity 3, :fn-var true, :arglists ([&form &env test & body]), :doc "Evaluates test. If logical false, evaluates body in an implicit do."}, when {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 390, :column 19, :end-line 390, :end-column 23, :macro true, :arglists (quote ([test & body])), :doc "Evaluates test. If logical true, evaluates body in an implicit do.", :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env test body)], :arglists ([&form &env test & body]), :arglists-meta (nil)}}, :name cljs.core$macros/when, :variadic true, :file "out/cljs/core.cljc", :end-column 23, :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env test body)], :arglists ([&form &env test & body]), :arglists-meta (nil)}, :method-params [(&form &env test body)], :protocol-impl nil, :arglists-meta (nil), :column 4, :line 390, :macro true, :end-line 390, :max-fixed-arity 3, :fn-var true, :arglists ([&form &env test & body]), :doc "Evaluates test. If logical true, evaluates body in an implicit do."}, int {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 1132, :column 31, :end-line 1132, :end-column 34, :cljs.analyzer/numeric true, :macro true, :arglists (quote ([x]))}, :name cljs.core$macros/int, :variadic false, :file "out/cljs/core.cljc", :end-column 34, :method-params ([&form &env x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1132, :macro true, :end-line 1132, :max-fixed-arity 3, :fn-var true, :arglists (quote ([x])), :cljs.analyzer/numeric true}, multi-arity-fn {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 2827, :column 13, :end-line 2827, :end-column 27, :private true, :arglists (quote ([name meta fdecl emit-var?]))}, :private true, :name cljs.core$macros/multi-arity-fn, :variadic false, :file "out/cljs/core.cljc", :end-column 27, :method-params ([name meta fdecl emit-var?]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2827, :end-line 2827, :max-fixed-arity 4, :fn-var true, :arglists (quote ([name meta fdecl emit-var?]))}, > {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 1071, :column 31, :end-line 1071, :end-column 32, :cljs.analyzer/numeric true, :macro true, :arglists (quote ([x] [x y] [x y & more])), :top-fn {:variadic true, :max-fixed-arity 4, :method-params ([&form &env x] [&form &env x y]), :arglists ([&form &env x] [&form &env x y] [&form &env x y & more]), :arglists-meta (nil nil nil)}}, :name cljs.core$macros/>, :variadic true, :file "out/cljs/core.cljc", :end-column 32, :top-fn {:variadic true, :max-fixed-arity 4, :method-params ([&form &env x] [&form &env x y]), :arglists ([&form &env x] [&form &env x y] [&form &env x y & more]), :arglists-meta (nil nil nil)}, :method-params ([&form &env x] [&form &env x y]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 1071, :macro true, :end-line 1071, :max-fixed-arity 4, :fn-var true, :arglists ([&form &env x] [&form &env x y] [&form &env x y & more]), :cljs.analyzer/numeric true}, keyword? {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 963, :column 16, :end-line 963, :end-column 24, :macro true, :arglists (quote ([x]))}, :name cljs.core$macros/keyword?, :variadic false, :file "out/cljs/core.cljc", :end-column 24, :method-params ([&form &env x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 963, :macro true, :end-line 963, :max-fixed-arity 3, :fn-var true, :arglists (quote ([x]))}, ->impl-map {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 1354, :column 13, :end-line 1354, :end-column 23, :private true, :arglists (quote ([impls]))}, :private true, :name cljs.core$macros/->impl-map, :variadic false, :file "out/cljs/core.cljc", :end-column 23, :method-params ([impls]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1354, :end-line 1354, :max-fixed-arity 1, :fn-var true, :arglists (quote ([impls]))}, js-obj* {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 2469, :column 13, :end-line 2469, :end-column 20, :private true, :arglists (quote ([kvs]))}, :private true, :name cljs.core$macros/js-obj*, :variadic false, :file "out/cljs/core.cljc", :end-column 20, :method-params ([kvs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2469, :end-line 2469, :max-fixed-arity 1, :fn-var true, :arglists (quote ([kvs]))}, unchecked-multiply {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 1019, :column 31, :end-line 1019, :end-column 49, :cljs.analyzer/numeric true, :macro true, :arglists (quote ([& xs])), :top-fn {:variadic true, :max-fixed-arity 2, :method-params [(&form &env xs)], :arglists ([&form &env & xs]), :arglists-meta (nil)}}, :name cljs.core$macros/unchecked-multiply, :variadic true, :file "out/cljs/core.cljc", :end-column 49, :top-fn {:variadic true, :max-fixed-arity 2, :method-params [(&form &env xs)], :arglists ([&form &env & xs]), :arglists-meta (nil)}, :method-params [(&form &env xs)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 1019, :macro true, :end-line 1019, :max-fixed-arity 2, :fn-var true, :arglists ([&form &env & xs]), :cljs.analyzer/numeric true}, gen-apply-to {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 2649, :column 16, :end-line 2649, :end-column 28, :macro true, :arglists (quote ([]))}, :name cljs.core$macros/gen-apply-to, :variadic false, :file "out/cljs/core.cljc", :end-column 28, :method-params ([&form &env]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2649, :macro true, :end-line 2649, :max-fixed-arity 2, :fn-var true, :arglists (quote ([]))}, some->> {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 490, :column 19, :end-line 490, :end-column 26, :macro true, :arglists (quote ([expr & forms])), :doc "When expr is not nil, threads it into the first form (via ->>),\n     and when that result is not nil, through the next etc", :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env expr forms)], :arglists ([&form &env expr & forms]), :arglists-meta (nil)}}, :name cljs.core$macros/some->>, :variadic true, :file "out/cljs/core.cljc", :end-column 26, :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env expr forms)], :arglists ([&form &env expr & forms]), :arglists-meta (nil)}, :method-params [(&form &env expr forms)], :protocol-impl nil, :arglists-meta (nil), :column 4, :line 490, :macro true, :end-line 490, :max-fixed-arity 3, :fn-var true, :arglists ([&form &env expr & forms]), :doc "When expr is not nil, threads it into the first form (via ->>),\n     and when that result is not nil, through the next etc"}, unchecked-dec {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 1004, :column 31, :end-line 1004, :end-column 44, :cljs.analyzer/numeric true, :macro true, :arglists (quote ([x]))}, :name cljs.core$macros/unchecked-dec, :variadic false, :file "out/cljs/core.cljc", :end-column 44, :method-params ([&form &env x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1004, :macro true, :end-line 1004, :max-fixed-arity 3, :fn-var true, :arglists (quote ([x])), :cljs.analyzer/numeric true}, defn {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 2902, :column 3, :end-line 2902, :end-column 7, :doc "Same as (def name (core/fn [params* ] exprs*)) or (def\n    name (core/fn ([params* ] exprs*)+)) with any doc-string or attrs added\n    to the var metadata. prepost-map defines a map with optional keys\n    :pre and :post that contain collections of pre or post conditions.", :arglists (quote ([name doc-string? attr-map? [params*] prepost-map? body] [name doc-string? attr-map? ([params*] prepost-map? body) + attr-map?]))}, :name cljs.core$macros/defn, :variadic true, :file "out/cljs/core.cljc", :end-column 7, :method-params ([&form &env name fdecl]), :protocol-impl nil, :arglists-meta (nil {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 2900, :column 16, :end-line 2901, :end-column 88}), :column 1, :line 2895, :end-line 2902, :max-fixed-arity 3, :fn-var true, :arglists (quote ([name doc-string? attr-map? [params*] prepost-map? body] [name doc-string? attr-map? ([params*] prepost-map? body) + attr-map?])), :doc "Same as (def name (core/fn [params* ] exprs*)) or (def\n    name (core/fn ([params* ] exprs*)+)) with any doc-string or attrs added\n    to the var metadata. prepost-map defines a map with optional keys\n    :pre and :post that contain collections of pre or post conditions."}, float {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 989, :column 16, :end-line 989, :end-column 21, :macro true, :arglists (quote ([x]))}, :name cljs.core$macros/float, :variadic false, :file "out/cljs/core.cljc", :end-column 21, :method-params ([&form &env x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 989, :macro true, :end-line 989, :max-fixed-arity 3, :fn-var true, :arglists (quote ([x]))}, js-in {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 887, :column 16, :end-line 887, :end-column 21, :macro true, :arglists (quote ([key obj]))}, :name cljs.core$macros/js-in, :variadic false, :file "out/cljs/core.cljc", :end-column 21, :method-params ([&form &env key obj]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 887, :macro true, :end-line 887, :max-fixed-arity 4, :fn-var true, :arglists (quote ([key obj]))}, es6-iterable {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 2682, :column 16, :end-line 2682, :end-column 28, :macro true, :arglists (quote ([ty]))}, :name cljs.core$macros/es6-iterable, :variadic false, :file "out/cljs/core.cljc", :end-column 28, :method-params ([&form &env ty]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2682, :macro true, :end-line 2682, :max-fixed-arity 3, :fn-var true, :arglists (quote ([ty]))}, amap {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 2503, :column 16, :end-line 2503, :end-column 20, :macro true, :arglists (quote ([a idx ret expr])), :doc "Maps an expression across an array a, using an index named idx, and\n  return value named ret, initialized to a clone of a, then setting\n  each element of ret to the evaluation of expr, returning the new\n  array ret."}, :name cljs.core$macros/amap, :variadic false, :file "out/cljs/core.cljc", :end-column 20, :method-params ([&form &env a idx ret expr]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2503, :macro true, :end-line 2503, :max-fixed-arity 6, :fn-var true, :arglists (quote ([a idx ret expr])), :doc "Maps an expression across an array a, using an index named idx, and\n  return value named ret, initialized to a clone of a, then setting\n  each element of ret to the evaluation of expr, returning the new\n  array ret."}, type-hint-impl-map {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 1531, :column 13, :end-line 1531, :end-column 31, :private true, :arglists (quote ([type-sym impl-map]))}, :private true, :name cljs.core$macros/type-hint-impl-map, :variadic false, :file "out/cljs/core.cljc", :end-column 31, :method-params ([type-sym impl-map]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1531, :end-line 1531, :max-fixed-arity 2, :fn-var true, :arglists (quote ([type-sym impl-map]))}, declare {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 171, :column 19, :end-line 171, :end-column 26, :macro true, :arglists (quote ([& names])), :doc "defs the supplied var names with no bindings, useful for making forward declarations.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params [(&form &env names)], :arglists ([&form &env & names]), :arglists-meta (nil)}}, :name cljs.core$macros/declare, :variadic true, :file "out/cljs/core.cljc", :end-column 26, :top-fn {:variadic true, :max-fixed-arity 2, :method-params [(&form &env names)], :arglists ([&form &env & names]), :arglists-meta (nil)}, :method-params [(&form &env names)], :protocol-impl nil, :arglists-meta (nil), :column 4, :line 171, :macro true, :end-line 171, :max-fixed-arity 2, :fn-var true, :arglists ([&form &env & names]), :doc "defs the supplied var names with no bindings, useful for making forward declarations."}, fast-path-protocol-partitions-count {:name cljs.core$macros/fast-path-protocol-partitions-count, :file "out/cljs/core.cljc", :line 797, :column 1, :end-line 797, :end-column 41, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 797, :column 6, :end-line 797, :end-column 41}, :doc "total number of partitions"}, - {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 1040, :column 31, :end-line 1040, :end-column 32, :cljs.analyzer/numeric true, :macro true, :arglists (quote ([x] [x y] [x y & more])), :top-fn {:variadic true, :max-fixed-arity 4, :method-params ([&form &env x] [&form &env x y]), :arglists ([&form &env x] [&form &env x y] [&form &env x y & more]), :arglists-meta (nil nil nil)}}, :name cljs.core$macros/-, :variadic true, :file "out/cljs/core.cljc", :end-column 32, :top-fn {:variadic true, :max-fixed-arity 4, :method-params ([&form &env x] [&form &env x y]), :arglists ([&form &env x] [&form &env x y] [&form &env x y & more]), :arglists-meta (nil nil nil)}, :method-params ([&form &env x] [&form &env x y]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 1040, :macro true, :end-line 1040, :max-fixed-arity 4, :fn-var true, :arglists ([&form &env x] [&form &env x y] [&form &env x y & more]), :cljs.analyzer/numeric true}, extend-prefix {:name cljs.core$macros/extend-prefix, :file "out/cljs/core.cljc", :line 1372, :column 1, :end-line 1372, :end-column 29, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 1372, :column 16, :end-line 1372, :end-column 29}}, hash-set {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 2455, :column 16, :end-line 2455, :end-column 24, :macro true, :arglists (quote ([] [& xs])), :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([&form &env]), :arglists ([&form &env] [&form &env & xs]), :arglists-meta (nil nil)}}, :name cljs.core$macros/hash-set, :variadic true, :file "out/cljs/core.cljc", :end-column 24, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([&form &env]), :arglists ([&form &env] [&form &env & xs]), :arglists-meta (nil nil)}, :method-params ([&form &env]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2455, :macro true, :end-line 2455, :max-fixed-arity 2, :fn-var true, :arglists ([&form &env] [&form &env & xs])}, or {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 837, :column 16, :end-line 837, :end-column 18, :macro true, :arglists (quote ([] [x] [x & next])), :doc "Evaluates exprs one at a time, from left to right. If a form\n  returns a logical true value, or returns that value and doesn't\n  evaluate any of the other expressions, otherwise it returns the\n  value of the last expression. (or) returns nil.", :top-fn {:variadic true, :max-fixed-arity 3, :method-params ([&form &env] [&form &env x]), :arglists ([&form &env] [&form &env x] [&form &env x & next]), :arglists-meta (nil nil nil)}}, :name cljs.core$macros/or, :variadic true, :file "out/cljs/core.cljc", :end-column 18, :top-fn {:variadic true, :max-fixed-arity 3, :method-params ([&form &env] [&form &env x]), :arglists ([&form &env] [&form &env x] [&form &env x & next]), :arglists-meta (nil nil nil)}, :method-params ([&form &env] [&form &env x]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 837, :macro true, :end-line 837, :max-fixed-arity 3, :fn-var true, :arglists ([&form &env] [&form &env x] [&form &env x & next]), :doc "Evaluates exprs one at a time, from left to right. If a form\n  returns a logical true value, or returns that value and doesn't\n  evaluate any of the other expressions, otherwise it returns the\n  value of the last expression. (or) returns nil."}, extend-type {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 1537, :column 16, :end-line 1537, :end-column 27, :macro true, :arglists (quote ([type-sym & impls])), :doc "Extend a type to a series of protocols. Useful when you are\n  supplying the definitions explicitly inline. Propagates the\n  type as a type hint on the first argument of all fns.\n\n  type-sym may be\n\n   * default, meaning the definitions will apply for any value,\n     unless an extend-type exists for one of the more specific\n     cases below.\n   * nil, meaning the definitions will apply for the nil value.\n   * any of object, boolean, number, string, array, or function,\n     indicating the definitions will apply for values of the\n     associated base JavaScript types. Note that, for example,\n     string should be used instead of js/String.\n   * a JavaScript type not covered by the previous list, such\n     as js/RegExp.\n   * a type defined by deftype or defrecord.\n\n  (extend-type MyType\n    ICounted\n    (-count [c] ...)\n    Foo\n    (bar [x y] ...)\n    (baz ([x] ...) ([x y & zs] ...))", :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env type-sym impls)], :arglists ([&form &env type-sym & impls]), :arglists-meta (nil)}}, :name cljs.core$macros/extend-type, :variadic true, :file "out/cljs/core.cljc", :end-column 27, :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env type-sym impls)], :arglists ([&form &env type-sym & impls]), :arglists-meta (nil)}, :method-params [(&form &env type-sym impls)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 1537, :macro true, :end-line 1537, :max-fixed-arity 3, :fn-var true, :arglists ([&form &env type-sym & impls]), :doc "Extend a type to a series of protocols. Useful when you are\n  supplying the definitions explicitly inline. Propagates the\n  type as a type hint on the first argument of all fns.\n\n  type-sym may be\n\n   * default, meaning the definitions will apply for any value,\n     unless an extend-type exists for one of the more specific\n     cases below.\n   * nil, meaning the definitions will apply for the nil value.\n   * any of object, boolean, number, string, array, or function,\n     indicating the definitions will apply for values of the\n     associated base JavaScript types. Note that, for example,\n     string should be used instead of js/String.\n   * a JavaScript type not covered by the previous list, such\n     as js/RegExp.\n   * a type defined by deftype or defrecord.\n\n  (extend-type MyType\n    ICounted\n    (-count [c] ...)\n    Foo\n    (bar [x y] ...)\n    (baz ([x] ...) ([x y & zs] ...))"}, cs {:name cljs.core$macros/cs, :file "out/cljs/core.cljc", :line 2632, :column 1, :end-line 2632, :end-column 8, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 2632, :column 6, :end-line 2632, :end-column 8}}, macroexpand-1 {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 2723, :column 16, :end-line 2723, :end-column 29, :macro true, :arglists (quote ([quoted])), :doc "If form represents a macro form, returns its expansion,\n  else returns form."}, :name cljs.core$macros/macroexpand-1, :variadic false, :file "out/cljs/core.cljc", :end-column 29, :method-params ([&form &env quoted]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2723, :macro true, :end-line 2723, :max-fixed-arity 3, :fn-var true, :arglists (quote ([quoted])), :doc "If form represents a macro form, returns its expansion,\n  else returns form."}, bit-test {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 1149, :column 16, :end-line 1149, :end-column 24, :macro true, :arglists (quote ([x n]))}, :name cljs.core$macros/bit-test, :variadic false, :file "out/cljs/core.cljc", :end-column 24, :method-params ([&form &env x n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1149, :macro true, :end-line 1149, :max-fixed-arity 4, :fn-var true, :arglists (quote ([x n]))}, defmethod {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 2599, :column 16, :end-line 2599, :end-column 25, :macro true, :arglists (quote ([multifn dispatch-val & fn-tail])), :doc "Creates and installs a new method of multimethod associated with dispatch-value. ", :top-fn {:variadic true, :max-fixed-arity 4, :method-params [(&form &env multifn dispatch-val fn-tail)], :arglists ([&form &env multifn dispatch-val & fn-tail]), :arglists-meta (nil)}}, :name cljs.core$macros/defmethod, :variadic true, :file "out/cljs/core.cljc", :end-column 25, :top-fn {:variadic true, :max-fixed-arity 4, :method-params [(&form &env multifn dispatch-val fn-tail)], :arglists ([&form &env multifn dispatch-val & fn-tail]), :arglists-meta (nil)}, :method-params [(&form &env multifn dispatch-val fn-tail)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 2599, :macro true, :end-line 2599, :max-fixed-arity 4, :fn-var true, :arglists ([&form &env multifn dispatch-val & fn-tail]), :doc "Creates and installs a new method of multimethod associated with dispatch-value. "}, time {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 2604, :column 16, :end-line 2604, :end-column 20, :macro true, :arglists (quote ([expr])), :doc "Evaluates expr and prints the time it took. Returns the value of expr."}, :name cljs.core$macros/time, :variadic false, :file "out/cljs/core.cljc", :end-column 20, :method-params ([&form &env expr]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2604, :macro true, :end-line 2604, :max-fixed-arity 3, :fn-var true, :arglists (quote ([expr])), :doc "Evaluates expr and prints the time it took. Returns the value of expr."}, type-hint-single-arity-sig {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 1513, :column 13, :end-line 1513, :end-column 39, :private true, :arglists (quote ([type-sym sig]))}, :private true, :name cljs.core$macros/type-hint-single-arity-sig, :variadic false, :file "out/cljs/core.cljc", :end-column 39, :method-params ([type-sym sig]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1513, :end-line 1513, :max-fixed-arity 2, :fn-var true, :arglists (quote ([type-sym sig]))}, zero? {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 1092, :column 31, :end-line 1092, :end-column 36, :cljs.analyzer/numeric true, :macro true, :arglists (quote ([x]))}, :name cljs.core$macros/zero?, :variadic false, :file "out/cljs/core.cljc", :end-column 36, :method-params ([&form &env x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1092, :macro true, :end-line 1092, :max-fixed-arity 3, :fn-var true, :arglists (quote ([x])), :cljs.analyzer/numeric true}, unchecked-dec-int {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 1007, :column 31, :end-line 1007, :end-column 48, :cljs.analyzer/numeric true, :macro true, :arglists (quote ([x]))}, :name cljs.core$macros/unchecked-dec-int, :variadic false, :file "out/cljs/core.cljc", :end-column 48, :method-params ([&form &env x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1007, :macro true, :end-line 1007, :max-fixed-arity 3, :fn-var true, :arglists (quote ([x])), :cljs.analyzer/numeric true}, proto-assign-impls {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 1446, :column 13, :end-line 1446, :end-column 31, :private true, :arglists (quote ([env resolve type-sym type [p sigs]]))}, :private true, :name cljs.core$macros/proto-assign-impls, :variadic false, :file "out/cljs/core.cljc", :end-column 31, :method-params ([env resolve type-sym type p__14023]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1446, :end-line 1446, :max-fixed-arity 5, :fn-var true, :arglists (quote ([env resolve type-sym type [p sigs]]))}, memfn {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 377, :column 19, :end-line 377, :end-column 24, :macro true, :arglists (quote ([name & args])), :doc "Expands into code that creates a fn that expects to be passed an\n     object and any args and calls the named instance method on the\n     object passing the args. Use when you want to treat a Java method as\n     a first-class fn. name may be type-hinted with the method receiver's\n     type in order to avoid reflective calls.", :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env name args)], :arglists ([&form &env name & args]), :arglists-meta (nil)}}, :name cljs.core$macros/memfn, :variadic true, :file "out/cljs/core.cljc", :end-column 24, :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env name args)], :arglists ([&form &env name & args]), :arglists-meta (nil)}, :method-params [(&form &env name args)], :protocol-impl nil, :arglists-meta (nil), :column 4, :line 377, :macro true, :end-line 377, :max-fixed-arity 3, :fn-var true, :arglists ([&form &env name & args]), :doc "Expands into code that creates a fn that expects to be passed an\n     object and any args and calls the named instance method on the\n     object passing the args. Use when you want to treat a Java method as\n     a first-class fn. name may be type-hinted with the method receiver's\n     type in order to avoid reflective calls."}, parse-impls {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 193, :column 16, :end-line 193, :end-column 27, :private true, :arglists (quote ([specs]))}, :private true, :name cljs.core$macros/parse-impls, :variadic false, :file "out/cljs/core.cljc", :end-column 27, :method-params ([specs]), :protocol-impl nil, :arglists-meta (nil nil), :column 4, :line 193, :end-line 193, :max-fixed-arity 1, :fn-var true, :arglists (quote ([specs]))}, js-obj {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 2478, :column 16, :end-line 2478, :end-column 22, :macro true, :arglists (quote ([& rest])), :top-fn {:variadic true, :max-fixed-arity 2, :method-params [(&form &env rest)], :arglists ([&form &env & rest]), :arglists-meta (nil)}}, :name cljs.core$macros/js-obj, :variadic true, :file "out/cljs/core.cljc", :end-column 22, :top-fn {:variadic true, :max-fixed-arity 2, :method-params [(&form &env rest)], :arglists ([&form &env & rest]), :arglists-meta (nil)}, :method-params [(&form &env rest)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 2478, :macro true, :end-line 2478, :max-fixed-arity 2, :fn-var true, :arglists ([&form &env & rest])}, nil? {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 855, :column 16, :end-line 855, :end-column 20, :macro true, :arglists (quote ([x]))}, :name cljs.core$macros/nil?, :variadic false, :file "out/cljs/core.cljc", :end-column 20, :method-params ([&form &env x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 855, :macro true, :end-line 855, :max-fixed-arity 3, :fn-var true, :arglists (quote ([x]))}, type-hint-first-arg {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 1509, :column 13, :end-line 1509, :end-column 32, :private true, :arglists (quote ([type-sym argv]))}, :private true, :name cljs.core$macros/type-hint-first-arg, :variadic false, :file "out/cljs/core.cljc", :end-column 32, :method-params ([type-sym argv]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1509, :end-line 1509, :max-fixed-arity 2, :fn-var true, :arglists (quote ([type-sym argv]))}, extend-protocol {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 209, :column 19, :end-line 209, :end-column 34, :macro true, :arglists (quote ([p & specs])), :doc "Useful when you want to provide several implementations of the same\n     protocol all at once. Takes a single protocol and the implementation\n     of that protocol for one or more types. Expands into calls to\n     extend-type:\n\n     (extend-protocol Protocol\n       AType\n         (foo [x] ...)\n         (bar [x y] ...)\n       BType\n         (foo [x] ...)\n         (bar [x y] ...)\n       AClass\n         (foo [x] ...)\n         (bar [x y] ...)\n       nil\n         (foo [x] ...)\n         (bar [x y] ...))\n\n     expands into:\n\n     (do\n      (clojure.core/extend-type AType Protocol\n        (foo [x] ...)\n        (bar [x y] ...))\n      (clojure.core/extend-type BType Protocol\n        (foo [x] ...)\n        (bar [x y] ...))\n      (clojure.core/extend-type AClass Protocol\n        (foo [x] ...)\n        (bar [x y] ...))\n      (clojure.core/extend-type nil Protocol\n        (foo [x] ...)\n        (bar [x y] ...)))", :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env p specs)], :arglists ([&form &env p & specs]), :arglists-meta (nil)}}, :name cljs.core$macros/extend-protocol, :variadic true, :file "out/cljs/core.cljc", :end-column 34, :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env p specs)], :arglists ([&form &env p & specs]), :arglists-meta (nil)}, :method-params [(&form &env p specs)], :protocol-impl nil, :arglists-meta (nil), :column 4, :line 209, :macro true, :end-line 209, :max-fixed-arity 3, :fn-var true, :arglists ([&form &env p & specs]), :doc "Useful when you want to provide several implementations of the same\n     protocol all at once. Takes a single protocol and the implementation\n     of that protocol for one or more types. Expands into calls to\n     extend-type:\n\n     (extend-protocol Protocol\n       AType\n         (foo [x] ...)\n         (bar [x y] ...)\n       BType\n         (foo [x] ...)\n         (bar [x y] ...)\n       AClass\n         (foo [x] ...)\n         (bar [x y] ...)\n       nil\n         (foo [x] ...)\n         (bar [x y] ...))\n\n     expands into:\n\n     (do\n      (clojure.core/extend-type AType Protocol\n        (foo [x] ...)\n        (bar [x y] ...))\n      (clojure.core/extend-type BType Protocol\n        (foo [x] ...)\n        (bar [x y] ...))\n      (clojure.core/extend-type AClass Protocol\n        (foo [x] ...)\n        (bar [x y] ...))\n      (clojure.core/extend-type nil Protocol\n        (foo [x] ...)\n        (bar [x y] ...)))"}, cond-> {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 441, :column 19, :end-line 441, :end-column 25, :macro true, :arglists (quote ([expr & clauses])), :doc "Takes an expression and a set of test/form pairs. Threads expr (via ->)\n     through each form for which the corresponding test\n     expression is true. Note that, unlike cond branching, cond-> threading does\n     not short circuit after the first true test expression.", :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env expr clauses)], :arglists ([&form &env expr & clauses]), :arglists-meta (nil)}}, :name cljs.core$macros/cond->, :variadic true, :file "out/cljs/core.cljc", :end-column 25, :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env expr clauses)], :arglists ([&form &env expr & clauses]), :arglists-meta (nil)}, :method-params [(&form &env expr clauses)], :protocol-impl nil, :arglists-meta (nil), :column 4, :line 441, :macro true, :end-line 441, :max-fixed-arity 3, :fn-var true, :arglists ([&form &env expr & clauses]), :doc "Takes an expression and a set of test/form pairs. Threads expr (via ->)\n     through each form for which the corresponding test\n     expression is true. Note that, unlike cond branching, cond-> threading does\n     not short circuit after the first true test expression."}, dotimes {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 2529, :column 16, :end-line 2529, :end-column 23, :macro true, :arglists (quote ([bindings & body])), :doc "bindings => name n\n\n  Repeatedly executes body (presumably for side-effects) with name\n  bound to integers from 0 through n-1.", :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env bindings body)], :arglists ([&form &env bindings & body]), :arglists-meta (nil)}}, :name cljs.core$macros/dotimes, :variadic true, :file "out/cljs/core.cljc", :end-column 23, :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env bindings body)], :arglists ([&form &env bindings & body]), :arglists-meta (nil)}, :method-params [(&form &env bindings body)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 2529, :macro true, :end-line 2529, :max-fixed-arity 3, :fn-var true, :arglists ([&form &env bindings & body]), :doc "bindings => name n\n\n  Repeatedly executes body (presumably for side-effects) with name\n  bound to integers from 0 through n-1."}, bit-and {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 1119, :column 31, :end-line 1119, :end-column 38, :cljs.analyzer/numeric true, :macro true, :arglists (quote ([x y] [x y & more])), :top-fn {:variadic true, :max-fixed-arity 4, :method-params ([&form &env x y]), :arglists ([&form &env x y] [&form &env x y & more]), :arglists-meta (nil nil)}}, :name cljs.core$macros/bit-and, :variadic true, :file "out/cljs/core.cljc", :end-column 38, :top-fn {:variadic true, :max-fixed-arity 4, :method-params ([&form &env x y]), :arglists ([&form &env x y] [&form &env x y & more]), :arglists-meta (nil nil)}, :method-params ([&form &env x y]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1119, :macro true, :end-line 1119, :max-fixed-arity 4, :fn-var true, :arglists ([&form &env x y] [&form &env x y & more]), :cljs.analyzer/numeric true}, reify {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 1242, :column 16, :end-line 1242, :end-column 21, :macro true, :arglists (quote ([& impls])), :doc "reify is a macro with the following structure:\n\n (reify options* specs*)\n\n  Currently there are no options.\n\n  Each spec consists of the protocol name followed by zero\n  or more method bodies:\n\n  protocol\n  (methodName [args+] body)*\n\n  Methods should be supplied for all methods of the desired\n  protocol(s). You can also define overrides for Object methods. Note that\n  the first parameter must be supplied to correspond to the target object\n  ('this' in JavaScript parlance). Note also that recur calls\n  to the method head should *not* pass the target object, it will be supplied\n  automatically and can not be substituted.\n\n  recur works to method heads The method bodies of reify are lexical\n  closures, and can refer to the surrounding local scope:\n\n  (str (let [f \"foo\"]\n       (reify Object\n         (toString [this] f))))\n  == \"foo\"\n\n  (seq (let [f \"foo\"]\n       (reify ISeqable\n         (-seq [this] (-seq f)))))\n  == (\\f \\o \\o))\n\n  reify always implements IMeta and IWithMeta and transfers meta\n  data of the form to the created object.\n\n  (meta ^{:k :v} (reify Object (toString [this] \"foo\")))\n  == {:k :v}", :top-fn {:variadic true, :max-fixed-arity 2, :method-params [(&form &env impls)], :arglists ([&form &env & impls]), :arglists-meta (nil)}}, :name cljs.core$macros/reify, :variadic true, :file "out/cljs/core.cljc", :end-column 21, :top-fn {:variadic true, :max-fixed-arity 2, :method-params [(&form &env impls)], :arglists ([&form &env & impls]), :arglists-meta (nil)}, :method-params [(&form &env impls)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 1242, :macro true, :end-line 1242, :max-fixed-arity 2, :fn-var true, :arglists ([&form &env & impls]), :doc "reify is a macro with the following structure:\n\n (reify options* specs*)\n\n  Currently there are no options.\n\n  Each spec consists of the protocol name followed by zero\n  or more method bodies:\n\n  protocol\n  (methodName [args+] body)*\n\n  Methods should be supplied for all methods of the desired\n  protocol(s). You can also define overrides for Object methods. Note that\n  the first parameter must be supplied to correspond to the target object\n  ('this' in JavaScript parlance). Note also that recur calls\n  to the method head should *not* pass the target object, it will be supplied\n  automatically and can not be substituted.\n\n  recur works to method heads The method bodies of reify are lexical\n  closures, and can refer to the surrounding local scope:\n\n  (str (let [f \"foo\"]\n       (reify Object\n         (toString [this] f))))\n  == \"foo\"\n\n  (seq (let [f \"foo\"]\n       (reify ISeqable\n         (-seq [this] (-seq f)))))\n  == (\\f \\o \\o))\n\n  reify always implements IMeta and IWithMeta and transfers meta\n  data of the form to the created object.\n\n  (meta ^{:k :v} (reify Object (toString [this] \"foo\")))\n  == {:k :v}"}, do-curried {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 1187, :column 13, :end-line 1187, :end-column 23, :private true, :arglists (quote ([name doc meta args body]))}, :private true, :name cljs.core$macros/do-curried, :variadic false, :file "out/cljs/core.cljc", :end-column 23, :method-params ([name doc meta args body]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1187, :end-line 1187, :max-fixed-arity 5, :fn-var true, :arglists (quote ([name doc meta args body]))}, instance? {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 948, :column 16, :end-line 948, :end-column 25, :macro true, :arglists (quote ([c x]))}, :name cljs.core$macros/instance?, :variadic false, :file "out/cljs/core.cljc", :end-column 25, :method-params ([&form &env c x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 948, :macro true, :end-line 948, :max-fixed-arity 4, :fn-var true, :arglists (quote ([c x]))}, load-file* {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 2720, :column 16, :end-line 2720, :end-column 26, :macro true, :arglists (quote ([f]))}, :name cljs.core$macros/load-file*, :variadic false, :file "out/cljs/core.cljc", :end-column 26, :method-params ([&form &env f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2720, :macro true, :end-line 2720, :max-fixed-arity 3, :fn-var true, :arglists (quote ([f]))}, defonce {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 603, :column 16, :end-line 603, :end-column 23, :macro true, :arglists (quote ([x init])), :doc "defs name to have the root value of init iff the named var has no root value,\n  else init is unevaluated"}, :name cljs.core$macros/defonce, :variadic false, :file "out/cljs/core.cljc", :end-column 23, :method-params ([&form &env x init]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 603, :macro true, :end-line 603, :max-fixed-arity 4, :fn-var true, :arglists (quote ([x init])), :doc "defs name to have the root value of init iff the named var has no root value,\n  else init is unevaluated"}, unchecked-add {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 998, :column 31, :end-line 998, :end-column 44, :cljs.analyzer/numeric true, :macro true, :arglists (quote ([& xs])), :top-fn {:variadic true, :max-fixed-arity 2, :method-params [(&form &env xs)], :arglists ([&form &env & xs]), :arglists-meta (nil)}}, :name cljs.core$macros/unchecked-add, :variadic true, :file "out/cljs/core.cljc", :end-column 44, :top-fn {:variadic true, :max-fixed-arity 2, :method-params [(&form &env xs)], :arglists ([&form &env & xs]), :arglists-meta (nil)}, :method-params [(&form &env xs)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 998, :macro true, :end-line 998, :max-fixed-arity 2, :fn-var true, :arglists ([&form &env & xs]), :cljs.analyzer/numeric true}, rfn {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 1211, :column 26, :end-line 1211, :end-column 29, :private true, :macro true, :arglists (quote ([[f1 k] fkv])), :doc "Builds 3-arity reducing fn given names of wrapped fn and key, and k/v impl."}, :private true, :name cljs.core$macros/rfn, :variadic false, :file "out/cljs/core.cljc", :end-column 29, :method-params ([&form &env p__13874 fkv]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1211, :macro true, :end-line 1211, :max-fixed-arity 4, :fn-var true, :arglists (quote ([[f1 k] fkv])), :doc "Builds 3-arity reducing fn given names of wrapped fn and key, and k/v impl."}, identical? {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 945, :column 16, :end-line 945, :end-column 26, :macro true, :arglists (quote ([a b]))}, :name cljs.core$macros/identical?, :variadic false, :file "out/cljs/core.cljc", :end-column 26, :method-params ([&form &env a b]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 945, :macro true, :end-line 945, :max-fixed-arity 4, :fn-var true, :arglists (quote ([a b]))}, collect-protocols {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 1623, :column 13, :end-line 1623, :end-column 30, :private true, :arglists (quote ([impls env]))}, :private true, :name cljs.core$macros/collect-protocols, :variadic false, :file "out/cljs/core.cljc", :end-column 30, :method-params ([impls env]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1623, :end-line 1623, :max-fixed-arity 2, :fn-var true, :arglists (quote ([impls env]))}, unchecked-divide-int {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 1010, :column 31, :end-line 1010, :end-column 51, :cljs.analyzer/numeric true, :macro true, :arglists (quote ([& xs])), :top-fn {:variadic true, :max-fixed-arity 2, :method-params [(&form &env xs)], :arglists ([&form &env & xs]), :arglists-meta (nil)}}, :name cljs.core$macros/unchecked-divide-int, :variadic true, :file "out/cljs/core.cljc", :end-column 51, :top-fn {:variadic true, :max-fixed-arity 2, :method-params [(&form &env xs)], :arglists ([&form &env & xs]), :arglists-meta (nil)}, :method-params [(&form &env xs)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 1010, :macro true, :end-line 1010, :max-fixed-arity 2, :fn-var true, :arglists ([&form &env & xs]), :cljs.analyzer/numeric true}, defn- {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 329, :column 19, :end-line 329, :end-column 24, :macro true, :arglists (quote ([name & decls])), :doc "same as defn, yielding non-public def", :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env name decls)], :arglists ([&form &env name & decls]), :arglists-meta (nil)}}, :name cljs.core$macros/defn-, :variadic true, :file "out/cljs/core.cljc", :end-column 24, :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env name decls)], :arglists ([&form &env name & decls]), :arglists-meta (nil)}, :method-params [(&form &env name decls)], :protocol-impl nil, :arglists-meta (nil), :column 4, :line 329, :macro true, :end-line 329, :max-fixed-arity 3, :fn-var true, :arglists ([&form &env name & decls]), :doc "same as defn, yielding non-public def"}, type-hint-multi-arity-sig {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 1517, :column 13, :end-line 1517, :end-column 38, :private true, :arglists (quote ([type-sym sig]))}, :private true, :name cljs.core$macros/type-hint-multi-arity-sig, :variadic false, :file "out/cljs/core.cljc", :end-column 38, :method-params ([type-sym sig]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1517, :end-line 1517, :max-fixed-arity 2, :fn-var true, :arglists (quote ([type-sym sig]))}, maybe-destructured {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 249, :column 4, :end-line 249, :end-column 22, :private true, :arglists (quote ([params body]))}, :private true, :name cljs.core$macros/maybe-destructured, :variadic false, :file "out/cljs/core.cljc", :end-column 22, :method-params ([params body]), :protocol-impl nil, :arglists-meta (nil nil), :column 4, :line 248, :end-line 249, :max-fixed-arity 2, :fn-var true, :arglists (quote ([params body]))}, defprotocol {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 1878, :column 16, :end-line 1878, :end-column 27, :macro true, :arglists (quote ([psym & doc+methods])), :doc "A protocol is a named set of named methods and their signatures:\n\n  (defprotocol AProtocolName\n    ;optional doc string\n    \"A doc string for AProtocol abstraction\"\n\n  ;method signatures\n    (bar [this a b] \"bar docs\")\n    (baz [this a] [this a b] [this a b c] \"baz docs\"))\n\n  No implementations are provided. Docs can be specified for the\n  protocol overall and for each method. The above yields a set of\n  polymorphic functions and a protocol object. All are\n  namespace-qualified by the ns enclosing the definition The resulting\n  functions dispatch on the type of their first argument, which is\n  required and corresponds to the implicit target object ('this' in\n  JavaScript parlance). defprotocol is dynamic, has no special compile-time\n  effect, and defines no new types.\n\n  (defprotocol P\n    (foo [this])\n    (bar-me [this] [this y]))\n\n  (deftype Foo [a b c]\n    P\n    (foo [this] a)\n    (bar-me [this] b)\n    (bar-me [this y] (+ c y)))\n\n  (bar-me (Foo. 1 2 3) 42)\n  => 45\n\n  (foo\n    (let [x 42]\n      (reify P\n        (foo [this] 17)\n        (bar-me [this] x)\n        (bar-me [this y] x))))\n  => 17", :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env psym doc+methods)], :arglists ([&form &env psym & doc+methods]), :arglists-meta (nil)}}, :name cljs.core$macros/defprotocol, :variadic true, :file "out/cljs/core.cljc", :end-column 27, :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env psym doc+methods)], :arglists ([&form &env psym & doc+methods]), :arglists-meta (nil)}, :method-params [(&form &env psym doc+methods)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 1878, :macro true, :end-line 1878, :max-fixed-arity 3, :fn-var true, :arglists ([&form &env psym & doc+methods]), :doc "A protocol is a named set of named methods and their signatures:\n\n  (defprotocol AProtocolName\n    ;optional doc string\n    \"A doc string for AProtocol abstraction\"\n\n  ;method signatures\n    (bar [this a b] \"bar docs\")\n    (baz [this a] [this a b] [this a b c] \"baz docs\"))\n\n  No implementations are provided. Docs can be specified for the\n  protocol overall and for each method. The above yields a set of\n  polymorphic functions and a protocol object. All are\n  namespace-qualified by the ns enclosing the definition The resulting\n  functions dispatch on the type of their first argument, which is\n  required and corresponds to the implicit target object ('this' in\n  JavaScript parlance). defprotocol is dynamic, has no special compile-time\n  effect, and defines no new types.\n\n  (defprotocol P\n    (foo [this])\n    (bar-me [this] [this y]))\n\n  (deftype Foo [a b c]\n    P\n    (foo [this] a)\n    (bar-me [this] b)\n    (bar-me [this y] (+ c y)))\n\n  (bar-me (Foo. 1 2 3) 42)\n  => 45\n\n  (foo\n    (let [x 42]\n      (reify P\n        (foo [this] 17)\n        (bar-me [this] x)\n        (bar-me [this y] x))))\n  => 17"}, unchecked-subtract {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 1034, :column 31, :end-line 1034, :end-column 49, :cljs.analyzer/numeric true, :macro true, :arglists (quote ([& xs])), :top-fn {:variadic true, :max-fixed-arity 2, :method-params [(&form &env xs)], :arglists ([&form &env & xs]), :arglists-meta (nil)}}, :name cljs.core$macros/unchecked-subtract, :variadic true, :file "out/cljs/core.cljc", :end-column 49, :top-fn {:variadic true, :max-fixed-arity 2, :method-params [(&form &env xs)], :arglists ([&form &env & xs]), :arglists-meta (nil)}, :method-params [(&form &env xs)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 1034, :macro true, :end-line 1034, :max-fixed-arity 2, :fn-var true, :arglists ([&form &env & xs]), :cljs.analyzer/numeric true}, variadic-fn {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 2792, :column 13, :end-line 2792, :end-column 24, :private true, :arglists (quote ([name meta [[arglist & body :as method] :as fdecl] emit-var?]))}, :private true, :name cljs.core$macros/variadic-fn, :variadic false, :file "out/cljs/core.cljc", :end-column 24, :method-params ([name meta p__14697 emit-var?]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2792, :end-line 2792, :max-fixed-arity 4, :fn-var true, :arglists (quote ([name meta [[arglist & body :as method] :as fdecl] emit-var?]))}, gen-apply-to-helper {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 2634, :column 13, :end-line 2634, :end-column 32, :private true, :arglists (quote ([] [n])), :top-fn {:variadic false, :max-fixed-arity 1, :method-params ([] [n]), :arglists ([] [n]), :arglists-meta (nil nil)}}, :private true, :name cljs.core$macros/gen-apply-to-helper, :variadic false, :file "out/cljs/core.cljc", :end-column 32, :top-fn {:variadic false, :max-fixed-arity 1, :method-params ([] [n]), :arglists ([] [n]), :arglists-meta (nil nil)}, :method-params ([] [n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2634, :end-line 2634, :max-fixed-arity 1, :fn-var true, :arglists ([] [n])}, ifn-invoke-methods {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 1411, :column 13, :end-line 1411, :end-column 31, :private true, :arglists (quote ([type type-sym [f & meths :as form]]))}, :private true, :name cljs.core$macros/ifn-invoke-methods, :variadic false, :file "out/cljs/core.cljc", :end-column 31, :method-params ([type type-sym p__13993]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1411, :end-line 1411, :max-fixed-arity 3, :fn-var true, :arglists (quote ([type type-sym [f & meths :as form]]))}, assert {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 2232, :column 16, :end-line 2232, :end-column 22, :macro true, :arglists (quote ([x] [x message])), :doc "Evaluates expr and throws an exception if it does not evaluate to\n  logical true.", :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([&form &env x] [&form &env x message]), :arglists ([&form &env x] [&form &env x message]), :arglists-meta (nil nil)}}, :name cljs.core$macros/assert, :variadic false, :file "out/cljs/core.cljc", :end-column 22, :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([&form &env x] [&form &env x message]), :arglists ([&form &env x] [&form &env x message]), :arglists-meta (nil nil)}, :method-params ([&form &env x] [&form &env x message]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2232, :macro true, :end-line 2232, :max-fixed-arity 4, :fn-var true, :arglists ([&form &env x] [&form &env x message]), :doc "Evaluates expr and throws an exception if it does not evaluate to\n  logical true."}, true? {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 922, :column 16, :end-line 922, :end-column 21, :macro true, :arglists (quote ([x]))}, :name cljs.core$macros/true?, :variadic false, :file "out/cljs/core.cljc", :end-column 21, :method-params ([&form &env x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 922, :macro true, :end-line 922, :max-fixed-arity 3, :fn-var true, :arglists (quote ([x]))}, array {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 2388, :column 16, :end-line 2388, :end-column 21, :macro true, :arglists (quote ([& rest])), :top-fn {:variadic true, :max-fixed-arity 2, :method-params [(&form &env rest)], :arglists ([&form &env & rest]), :arglists-meta (nil)}}, :name cljs.core$macros/array, :variadic true, :file "out/cljs/core.cljc", :end-column 21, :top-fn {:variadic true, :max-fixed-arity 2, :method-params [(&form &env rest)], :arglists ([&form &env & rest]), :arglists-meta (nil)}, :method-params [(&form &env rest)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 2388, :macro true, :end-line 2388, :max-fixed-arity 2, :fn-var true, :arglists ([&form &env & rest])}, multi-arity-fn? {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 2746, :column 13, :end-line 2746, :end-column 28, :private true, :arglists (quote ([fdecl]))}, :private true, :name cljs.core$macros/multi-arity-fn?, :variadic false, :file "out/cljs/core.cljc", :end-column 28, :method-params ([fdecl]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2746, :end-line 2746, :max-fixed-arity 1, :fn-var true, :arglists (quote ([fdecl]))}, letfn {:protocol-inline nil, :meta {:special-form true, :file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :end-column 24, :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env fnspecs body)], :arglists ([&form &env fnspecs & body]), :arglists-meta (nil)}, :column 19, :line 363, :macro true, :url nil, :end-line 363, :arglists (quote ([fnspecs & body])), :doc "fnspec ==> (fname [params*] exprs) or (fname ([params*] exprs)+)\n\n     Takes a vector of function specs and a body, and generates a set of\n     bindings of functions to their names. All of the names are available\n     in all of the definitions of the functions, as well as the body.", :forms (quote [(letfn [fnspecs*] exprs*)])}, :name cljs.core$macros/letfn, :variadic true, :special-form true, :file "out/cljs/core.cljc", :end-column 24, :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env fnspecs body)], :arglists ([&form &env fnspecs & body]), :arglists-meta (nil)}, :method-params [(&form &env fnspecs body)], :protocol-impl nil, :arglists-meta (nil), :column 4, :line 363, :macro true, :url nil, :end-line 363, :max-fixed-arity 3, :fn-var true, :arglists ([&form &env fnspecs & body]), :doc "fnspec ==> (fname [params*] exprs) or (fname ([params*] exprs)+)\n\n     Takes a vector of function specs and a body, and generates a set of\n     bindings of functions to their names. All of the names are available\n     in all of the definitions of the functions, as well as the body.", :forms (quote [(letfn [fnspecs*] exprs*)])}, / {:protocol-inline nil, :meta {:cljs.analyzer/numeric true, :macro true, :arglists (quote ([x] [x y] [x y & more])), :top-fn {:variadic true, :max-fixed-arity 4, :method-params ([&form &env x] [&form &env x y]), :arglists ([&form &env x] [&form &env x y] [&form &env x y & more]), :arglists-meta (nil nil nil)}, :file nil}, :name cljs.core$macros//, :variadic true, :file "out/cljs/core.cljc", :top-fn {:variadic true, :max-fixed-arity 4, :method-params ([&form &env x] [&form &env x y]), :arglists ([&form &env x] [&form &env x y] [&form &env x y & more]), :arglists-meta (nil nil nil)}, :method-params ([&form &env x] [&form &env x y]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 1051, :macro true, :max-fixed-arity 4, :fn-var true, :arglists ([&form &env x] [&form &env x y] [&form &env x y & more]), :cljs.analyzer/numeric true}, bitpos {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 1172, :column 16, :end-line 1172, :end-column 22, :macro true, :arglists (quote ([hash shift]))}, :name cljs.core$macros/bitpos, :variadic false, :file "out/cljs/core.cljc", :end-column 22, :method-params ([&form &env hash shift]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1172, :macro true, :end-line 1172, :max-fixed-arity 4, :fn-var true, :arglists (quote ([hash shift]))}, bit-or {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 1128, :column 31, :end-line 1128, :end-column 37, :cljs.analyzer/numeric true, :macro true, :arglists (quote ([x y] [x y & more])), :top-fn {:variadic true, :max-fixed-arity 4, :method-params ([&form &env x y]), :arglists ([&form &env x y] [&form &env x y & more]), :arglists-meta (nil nil)}}, :name cljs.core$macros/bit-or, :variadic true, :file "out/cljs/core.cljc", :end-column 37, :top-fn {:variadic true, :max-fixed-arity 4, :method-params ([&form &env x y]), :arglists ([&form &env x y] [&form &env x y & more]), :arglists-meta (nil nil)}, :method-params ([&form &env x y]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1128, :macro true, :end-line 1128, :max-fixed-arity 4, :fn-var true, :arglists ([&form &env x y] [&form &env x y & more]), :cljs.analyzer/numeric true}, vector {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 2424, :column 16, :end-line 2424, :end-column 22, :macro true, :arglists (quote ([] [& xs])), :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([&form &env]), :arglists ([&form &env] [&form &env & xs]), :arglists-meta (nil nil)}}, :name cljs.core$macros/vector, :variadic true, :file "out/cljs/core.cljc", :end-column 22, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([&form &env]), :arglists ([&form &env] [&form &env & xs]), :arglists-meta (nil nil)}, :method-params ([&form &env]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2424, :macro true, :end-line 2424, :max-fixed-arity 2, :fn-var true, :arglists ([&form &env] [&form &env & xs])}, adapt-obj-params {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 1380, :column 13, :end-line 1380, :end-column 29, :private true, :arglists (quote ([type [[this & args :as sig] & body]]))}, :private true, :name cljs.core$macros/adapt-obj-params, :variadic false, :file "out/cljs/core.cljc", :end-column 29, :method-params ([type p__13925]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1380, :end-line 1380, :max-fixed-arity 2, :fn-var true, :arglists (quote ([type [[this & args :as sig] & body]]))}, >= {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 1076, :column 31, :end-line 1076, :end-column 33, :cljs.analyzer/numeric true, :macro true, :arglists (quote ([x] [x y] [x y & more])), :top-fn {:variadic true, :max-fixed-arity 4, :method-params ([&form &env x] [&form &env x y]), :arglists ([&form &env x] [&form &env x y] [&form &env x y & more]), :arglists-meta (nil nil nil)}}, :name cljs.core$macros/>=, :variadic true, :file "out/cljs/core.cljc", :end-column 33, :top-fn {:variadic true, :max-fixed-arity 4, :method-params ([&form &env x] [&form &env x y]), :arglists ([&form &env x] [&form &env x y] [&form &env x y & more]), :arglists-meta (nil nil nil)}, :method-params ([&form &env x] [&form &env x y]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 1076, :macro true, :end-line 1076, :max-fixed-arity 4, :fn-var true, :arglists ([&form &env x] [&form &env x y] [&form &env x y & more]), :cljs.analyzer/numeric true}, loop {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 755, :column 16, :end-line 755, :end-column 20, :macro true, :arglists (quote ([bindings & body])), :doc "Evaluates the exprs in a lexical context in which the symbols in\n  the binding-forms are bound to their respective init-exprs or parts\n  therein. Acts as a recur target.", :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env bindings body)], :arglists ([&form &env bindings & body]), :arglists-meta (nil)}}, :name cljs.core$macros/loop, :variadic true, :file "out/cljs/core.cljc", :end-column 20, :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env bindings body)], :arglists ([&form &env bindings & body]), :arglists-meta (nil)}, :method-params [(&form &env bindings body)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 755, :macro true, :end-line 755, :max-fixed-arity 3, :fn-var true, :arglists ([&form &env bindings & body]), :doc "Evaluates the exprs in a lexical context in which the symbols in\n  the binding-forms are bound to their respective init-exprs or parts\n  therein. Acts as a recur target."}, add-obj-methods {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 1402, :column 13, :end-line 1402, :end-column 28, :private true, :arglists (quote ([type type-sym sigs]))}, :private true, :name cljs.core$macros/add-obj-methods, :variadic false, :file "out/cljs/core.cljc", :end-column 28, :method-params ([type type-sym sigs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1402, :end-line 1402, :max-fixed-arity 3, :fn-var true, :arglists (quote ([type type-sym sigs]))}, bit-flip {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 1146, :column 31, :end-line 1146, :end-column 39, :cljs.analyzer/numeric true, :macro true, :arglists (quote ([x n]))}, :name cljs.core$macros/bit-flip, :variadic false, :file "out/cljs/core.cljc", :end-column 39, :method-params ([&form &env x n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1146, :macro true, :end-line 1146, :max-fixed-arity 4, :fn-var true, :arglists (quote ([x n])), :cljs.analyzer/numeric true}, js-mod {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 1113, :column 31, :end-line 1113, :end-column 37, :cljs.analyzer/numeric true, :macro true, :arglists (quote ([num div]))}, :name cljs.core$macros/js-mod, :variadic false, :file "out/cljs/core.cljc", :end-column 37, :method-params ([&form &env num div]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1113, :macro true, :end-line 1113, :max-fixed-arity 4, :fn-var true, :arglists (quote ([num div])), :cljs.analyzer/numeric true}, to-property {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 1326, :column 13, :end-line 1326, :end-column 24, :private true, :arglists (quote ([sym]))}, :private true, :name cljs.core$macros/to-property, :variadic false, :file "out/cljs/core.cljc", :end-column 24, :method-params ([sym]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1326, :end-line 1326, :max-fixed-arity 1, :fn-var true, :arglists (quote ([sym]))}, variadic-fn* {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 2753, :column 13, :end-line 2753, :end-column 25, :private true, :arglists (quote ([sym method] [sym [arglist & body :as method] solo])), :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([sym method] [sym [arglist & body :as method] solo]), :arglists ([sym method] [sym [arglist & body :as method] solo]), :arglists-meta (nil nil)}}, :private true, :name cljs.core$macros/variadic-fn*, :variadic false, :file "out/cljs/core.cljc", :end-column 25, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([sym method] [sym [arglist & body :as method] solo]), :arglists ([sym method] [sym [arglist & body :as method] solo]), :arglists-meta (nil nil)}, :method-params ([sym method] [sym [arglist & body :as method] solo]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2753, :end-line 2753, :max-fixed-arity 3, :fn-var true, :arglists ([sym method] [sym [arglist & body :as method] solo])}, with-out-str {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 2659, :column 16, :end-line 2659, :end-column 28, :macro true, :arglists (quote ([& body])), :doc "Evaluates exprs in a context in which *print-fn* is bound to .append\n  on a fresh StringBuffer.  Returns the string created by any nested\n  printing calls.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params [(&form &env body)], :arglists ([&form &env & body]), :arglists-meta (nil)}}, :name cljs.core$macros/with-out-str, :variadic true, :file "out/cljs/core.cljc", :end-column 28, :top-fn {:variadic true, :max-fixed-arity 2, :method-params [(&form &env body)], :arglists ([&form &env & body]), :arglists-meta (nil)}, :method-params [(&form &env body)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 2659, :macro true, :end-line 2659, :max-fixed-arity 2, :fn-var true, :arglists ([&form &env & body]), :doc "Evaluates exprs in a context in which *print-fn* is bound to .append\n  on a fresh StringBuffer.  Returns the string created by any nested\n  printing calls."}, condp {:protocol-inline nil, :meta {:added "1.0", :file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :end-column 21, :top-fn {:variadic true, :max-fixed-arity 4, :method-params [(&form &env pred expr clauses)], :arglists ([&form &env pred expr & clauses]), :arglists-meta (nil)}, :column 16, :line 2097, :macro true, :end-line 2097, :arglists (quote ([pred expr & clauses])), :doc "Takes a binary predicate, an expression, and a set of clauses.\n  Each clause can take the form of either:\n\n  test-expr result-expr\n\n  test-expr :>> result-fn\n\n  Note :>> is an ordinary keyword.\n\n  For each clause, (pred test-expr expr) is evaluated. If it returns\n  logical true, the clause is a match. If a binary clause matches, the\n  result-expr is returned, if a ternary clause matches, its result-fn,\n  which must be a unary function, is called with the result of the\n  predicate as its argument, the result of that call being the return\n  value of condp. A single default expression can follow the clauses,\n  and its value will be returned if no clause matches. If no default\n  expression is provided and no clause matches, an\n  IllegalArgumentException is thrown."}, :added "1.0", :name cljs.core$macros/condp, :variadic true, :file "out/cljs/core.cljc", :end-column 21, :top-fn {:variadic true, :max-fixed-arity 4, :method-params [(&form &env pred expr clauses)], :arglists ([&form &env pred expr & clauses]), :arglists-meta (nil)}, :method-params [(&form &env pred expr clauses)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 2097, :macro true, :end-line 2097, :max-fixed-arity 4, :fn-var true, :arglists ([&form &env pred expr & clauses]), :doc "Takes a binary predicate, an expression, and a set of clauses.\n  Each clause can take the form of either:\n\n  test-expr result-expr\n\n  test-expr :>> result-fn\n\n  Note :>> is an ordinary keyword.\n\n  For each clause, (pred test-expr expr) is evaluated. If it returns\n  logical true, the clause is a match. If a binary clause matches, the\n  result-expr is returned, if a ternary clause matches, its result-fn,\n  which must be a unary function, is called with the result of the\n  predicate as its argument, the result of that call being the return\n  value of condp. A single default expression can follow the clauses,\n  and its value will be returned if no clause matches. If no default\n  expression is provided and no clause matches, an\n  IllegalArgumentException is thrown."}, cond {:protocol-inline nil, :meta {:added "1.0", :file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :end-column 23, :top-fn {:variadic true, :max-fixed-arity 2, :method-params [(&form &env clauses)], :arglists ([&form &env & clauses]), :arglists-meta (nil)}, :column 19, :line 156, :macro true, :end-line 156, :arglists (quote ([& clauses])), :doc "Takes a set of test/expr pairs. It evaluates each test one at a\n     time.  If a test returns logical true, cond evaluates and returns\n     the value of the corresponding expr and doesn't evaluate any of the\n     other tests or exprs. (cond) returns nil."}, :added "1.0", :name cljs.core$macros/cond, :variadic true, :file "out/cljs/core.cljc", :end-column 23, :top-fn {:variadic true, :max-fixed-arity 2, :method-params [(&form &env clauses)], :arglists ([&form &env & clauses]), :arglists-meta (nil)}, :method-params [(&form &env clauses)], :protocol-impl nil, :arglists-meta (nil), :column 4, :line 156, :macro true, :end-line 156, :max-fixed-arity 2, :fn-var true, :arglists ([&form &env & clauses]), :doc "Takes a set of test/expr pairs. It evaluates each test one at a\n     time.  If a test returns logical true, cond evaluates and returns\n     the value of the corresponding expr and doesn't evaluate any of the\n     other tests or exprs. (cond) returns nil."}, check-valid-options {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 2543, :column 13, :end-line 2543, :end-column 32, :private true, :arglists (quote ([options & valid-keys])), :doc "Throws an exception if the given option map contains keys not listed\n  as valid, else returns nil.", :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(options valid-keys)], :arglists ([options & valid-keys]), :arglists-meta (nil)}}, :private true, :name cljs.core$macros/check-valid-options, :variadic true, :file "out/cljs/core.cljc", :end-column 32, :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(options valid-keys)], :arglists ([options & valid-keys]), :arglists-meta (nil)}, :method-params [(options valid-keys)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 2543, :end-line 2543, :max-fixed-arity 1, :fn-var true, :arglists ([options & valid-keys]), :doc "Throws an exception if the given option map contains keys not listed\n  as valid, else returns nil."}, add-proto-methods* {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 1434, :column 13, :end-line 1434, :end-column 31, :private true, :arglists (quote ([pprefix type type-sym [f & meths :as form]]))}, :private true, :name cljs.core$macros/add-proto-methods*, :variadic false, :file "out/cljs/core.cljc", :end-column 31, :method-params ([pprefix type type-sym p__14008]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1434, :end-line 1434, :max-fixed-arity 4, :fn-var true, :arglists (quote ([pprefix type type-sym [f & meths :as form]]))}, some-> {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 479, :column 19, :end-line 479, :end-column 25, :macro true, :arglists (quote ([expr & forms])), :doc "When expr is not nil, threads it into the first form (via ->),\n     and when that result is not nil, through the next etc", :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env expr forms)], :arglists ([&form &env expr & forms]), :arglists-meta (nil)}}, :name cljs.core$macros/some->, :variadic true, :file "out/cljs/core.cljc", :end-column 25, :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env expr forms)], :arglists ([&form &env expr & forms]), :arglists-meta (nil)}, :method-params [(&form &env expr forms)], :protocol-impl nil, :arglists-meta (nil), :column 4, :line 479, :macro true, :end-line 479, :max-fixed-arity 3, :fn-var true, :arglists ([&form &env expr & forms]), :doc "When expr is not nil, threads it into the first form (via ->),\n     and when that result is not nil, through the next etc"}, ns-interns {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 2688, :column 16, :end-line 2688, :end-column 26, :macro true, :arglists (quote ([[quote ns]])), :doc "Returns a map of the intern mappings for the namespace."}, :name cljs.core$macros/ns-interns, :variadic false, :file "out/cljs/core.cljc", :end-column 26, :method-params ([&form &env p__14628]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2688, :macro true, :end-line 2688, :max-fixed-arity 3, :fn-var true, :arglists (quote ([[quote ns]])), :doc "Returns a map of the intern mappings for the namespace."}, base-assign-impls {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 1361, :column 13, :end-line 1361, :end-column 30, :private true, :arglists (quote ([env resolve tsym type [p sigs]]))}, :private true, :name cljs.core$macros/base-assign-impls, :variadic false, :file "out/cljs/core.cljc", :end-column 30, :method-params ([env resolve tsym type p__13910]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1361, :end-line 1361, :max-fixed-arity 5, :fn-var true, :arglists (quote ([env resolve tsym type [p sigs]]))}, for {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 2245, :column 16, :end-line 2245, :end-column 19, :macro true, :arglists (quote ([seq-exprs body-expr])), :doc "List comprehension. Takes a vector of one or more\n   binding-form/collection-expr pairs, each followed by zero or more\n   modifiers, and yields a lazy sequence of evaluations of expr.\n   Collections are iterated in a nested fashion, rightmost fastest,\n   and nested coll-exprs can refer to bindings created in prior\n   binding-forms.  Supported modifiers are: :let [binding-form expr ...],\n   :while test, :when test.\n\n  (take 100 (for [x (range 100000000) y (range 1000000) :while (< y x)]  [x y]))"}, :name cljs.core$macros/for, :variadic false, :file "out/cljs/core.cljc", :end-column 19, :method-params ([&form &env seq-exprs body-expr]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2245, :macro true, :end-line 2245, :max-fixed-arity 4, :fn-var true, :arglists (quote ([seq-exprs body-expr])), :doc "List comprehension. Takes a vector of one or more\n   binding-form/collection-expr pairs, each followed by zero or more\n   modifiers, and yields a lazy sequence of evaluations of expr.\n   Collections are iterated in a nested fashion, rightmost fastest,\n   and nested coll-exprs can refer to bindings created in prior\n   binding-forms.  Supported modifiers are: :let [binding-form expr ...],\n   :while test, :when test.\n\n  (take 100 (for [x (range 100000000) y (range 1000000) :while (< y x)]  [x y]))"}, binding {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 2084, :column 16, :end-line 2084, :end-column 23, :macro true, :arglists (quote ([bindings & body])), :doc "binding => var-symbol init-expr\n\n  Creates new bindings for the (already-existing) vars, with the\n  supplied initial values, executes the exprs in an implicit do, then\n  re-establishes the bindings that existed before.  The new bindings\n  are made in parallel (unlike let); all init-exprs are evaluated\n  before the vars are bound to their new values.", :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env bindings body)], :arglists ([&form &env bindings & body]), :arglists-meta (nil)}}, :name cljs.core$macros/binding, :variadic true, :file "out/cljs/core.cljc", :end-column 23, :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env bindings body)], :arglists ([&form &env bindings & body]), :arglists-meta (nil)}, :method-params [(&form &env bindings body)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 2084, :macro true, :end-line 2084, :max-fixed-arity 3, :fn-var true, :arglists ([&form &env bindings & body]), :doc "binding => var-symbol init-expr\n\n  Creates new bindings for the (already-existing) vars, with the\n  supplied initial values, executes the exprs in an implicit do, then\n  re-establishes the bindings that existed before.  The new bindings\n  are made in parallel (unlike let); all init-exprs are evaluated\n  before the vars are bound to their new values."}, array-map {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 2435, :column 16, :end-line 2435, :end-column 25, :macro true, :arglists (quote ([] [& kvs])), :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([&form &env]), :arglists ([&form &env] [&form &env & kvs]), :arglists-meta (nil nil)}}, :name cljs.core$macros/array-map, :variadic true, :file "out/cljs/core.cljc", :end-column 25, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([&form &env]), :arglists ([&form &env] [&form &env & kvs]), :arglists-meta (nil nil)}, :method-params ([&form &env]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2435, :macro true, :end-line 2435, :max-fixed-arity 2, :fn-var true, :arglists ([&form &env] [&form &env & kvs])}, unchecked-byte {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 992, :column 16, :end-line 992, :end-column 30, :macro true, :arglists (quote ([x]))}, :name cljs.core$macros/unchecked-byte, :variadic false, :file "out/cljs/core.cljc", :end-column 30, :method-params ([&form &env x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 992, :macro true, :end-line 992, :max-fixed-arity 3, :fn-var true, :arglists (quote ([x]))}, defmacro {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 2970, :column 12, :end-line 2970, :end-column 20, :arglists (quote ([name doc-string? attr-map? [params*] body] [name doc-string? attr-map? ([params*] body) + attr-map?])), :doc "Like defn, but the resulting function name is declared as a\n  macro and will be used as a macro by the compiler when it is\n  called.", :macro true, :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env name args)], :arglists ([&form &env name & args]), :arglists-meta (nil)}}, :name cljs.core$macros/defmacro, :variadic true, :file "out/cljs/core.cljc", :end-column 20, :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env name args)], :arglists ([&form &env name & args]), :arglists-meta (nil)}, :method-params [(&form &env name args)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 2970, :macro true, :end-line 2970, :max-fixed-arity 3, :fn-var true, :arglists ([&form &env name & args]), :doc "Like defn, but the resulting function name is declared as a\n  macro and will be used as a macro by the compiler when it is\n  called."}, unchecked-short {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 994, :column 16, :end-line 994, :end-column 31, :macro true, :arglists (quote ([x]))}, :name cljs.core$macros/unchecked-short, :variadic false, :file "out/cljs/core.cljc", :end-column 31, :method-params ([&form &env x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 994, :macro true, :end-line 994, :max-fixed-arity 3, :fn-var true, :arglists (quote ([x]))}, validate-fields {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 1638, :column 13, :end-line 1638, :end-column 28, :private true, :arglists (quote ([case name fields]))}, :private true, :name cljs.core$macros/validate-fields, :variadic false, :file "out/cljs/core.cljc", :end-column 28, :method-params ([case name fields]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1638, :end-line 1638, :max-fixed-arity 3, :fn-var true, :arglists (quote ([case name fields]))}, inc {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 1089, :column 31, :end-line 1089, :end-column 34, :cljs.analyzer/numeric true, :macro true, :arglists (quote ([x]))}, :name cljs.core$macros/inc, :variadic false, :file "out/cljs/core.cljc", :end-column 34, :method-params ([&form &env x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1089, :macro true, :end-line 1089, :max-fixed-arity 3, :fn-var true, :arglists (quote ([x])), :cljs.analyzer/numeric true}, with-redefs {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 2062, :column 16, :end-line 2062, :end-column 27, :macro true, :arglists (quote ([bindings & body])), :doc "binding => var-symbol temp-value-expr\n\n  Temporarily redefines vars while executing the body.  The\n  temp-value-exprs will be evaluated and each resulting value will\n  replace in parallel the root value of its var.  After the body is\n  executed, the root values of all the vars will be set back to their\n  old values. Useful for mocking out functions during testing.", :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env bindings body)], :arglists ([&form &env bindings & body]), :arglists-meta (nil)}}, :name cljs.core$macros/with-redefs, :variadic true, :file "out/cljs/core.cljc", :end-column 27, :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env bindings body)], :arglists ([&form &env bindings & body]), :arglists-meta (nil)}, :method-params [(&form &env bindings body)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 2062, :macro true, :end-line 2062, :max-fixed-arity 3, :fn-var true, :arglists ([&form &env bindings & body]), :doc "binding => var-symbol temp-value-expr\n\n  Temporarily redefines vars while executing the body.  The\n  temp-value-exprs will be evaluated and each resulting value will\n  replace in parallel the root value of its var.  After the body is\n  executed, the root values of all the vars will be set back to their\n  old values. Useful for mocking out functions during testing."}, bit-clear {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 1143, :column 31, :end-line 1143, :end-column 40, :cljs.analyzer/numeric true, :macro true, :arglists (quote ([x n]))}, :name cljs.core$macros/bit-clear, :variadic false, :file "out/cljs/core.cljc", :end-column 40, :method-params ([&form &env x n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1143, :macro true, :end-line 1143, :max-fixed-arity 4, :fn-var true, :arglists (quote ([x n])), :cljs.analyzer/numeric true}, locking {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 2715, :column 16, :end-line 2715, :end-column 23, :macro true, :arglists (quote ([x & forms])), :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env x forms)], :arglists ([&form &env x & forms]), :arglists-meta (nil)}}, :name cljs.core$macros/locking, :variadic true, :file "out/cljs/core.cljc", :end-column 23, :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env x forms)], :arglists ([&form &env x & forms]), :arglists-meta (nil)}, :method-params [(&form &env x forms)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 2715, :macro true, :end-line 2715, :max-fixed-arity 3, :fn-var true, :arglists ([&form &env x & forms])}, list {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 2415, :column 16, :end-line 2415, :end-column 20, :macro true, :arglists (quote ([] [x & xs])), :top-fn {:variadic true, :max-fixed-arity 3, :method-params ([&form &env]), :arglists ([&form &env] [&form &env x & xs]), :arglists-meta (nil nil)}}, :name cljs.core$macros/list, :variadic true, :file "out/cljs/core.cljc", :end-column 20, :top-fn {:variadic true, :max-fixed-arity 3, :method-params ([&form &env]), :arglists ([&form &env] [&form &env x & xs]), :arglists-meta (nil nil)}, :method-params ([&form &env]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2415, :macro true, :end-line 2415, :max-fixed-arity 3, :fn-var true, :arglists ([&form &env] [&form &env x & xs])}, + {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 981, :column 31, :end-line 981, :end-column 32, :cljs.analyzer/numeric true, :macro true, :arglists (quote ([] [x] [x y] [x y & more])), :top-fn {:variadic true, :max-fixed-arity 4, :method-params ([&form &env] [&form &env x] [&form &env x y]), :arglists ([&form &env] [&form &env x] [&form &env x y] [&form &env x y & more]), :arglists-meta (nil nil nil nil)}}, :name cljs.core$macros/+, :variadic true, :file "out/cljs/core.cljc", :end-column 32, :top-fn {:variadic true, :max-fixed-arity 4, :method-params ([&form &env] [&form &env x] [&form &env x y]), :arglists ([&form &env] [&form &env x] [&form &env x y] [&form &env x y & more]), :arglists-meta (nil nil nil nil)}, :method-params ([&form &env] [&form &env x] [&form &env x y]), :protocol-impl nil, :arglists-meta (nil nil nil nil), :column 1, :line 981, :macro true, :end-line 981, :max-fixed-arity 4, :fn-var true, :arglists ([&form &env] [&form &env x] [&form &env x y] [&form &env x y & more]), :cljs.analyzer/numeric true}, aset {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 973, :column 16, :end-line 973, :end-column 20, :macro true, :arglists (quote ([a i v] [a idx idx2 & idxv])), :top-fn {:variadic true, :max-fixed-arity 5, :method-params ([&form &env a i v]), :arglists ([&form &env a i v] [&form &env a idx idx2 & idxv]), :arglists-meta (nil nil)}}, :name cljs.core$macros/aset, :variadic true, :file "out/cljs/core.cljc", :end-column 20, :top-fn {:variadic true, :max-fixed-arity 5, :method-params ([&form &env a i v]), :arglists ([&form &env a i v] [&form &env a idx idx2 & idxv]), :arglists-meta (nil nil)}, :method-params ([&form &env a i v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 973, :macro true, :end-line 973, :max-fixed-arity 5, :fn-var true, :arglists ([&form &env a i v] [&form &env a idx idx2 & idxv])}, destructure {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 610, :column 12, :end-line 610, :end-column 23, :arglists (quote ([bindings]))}, :name cljs.core$macros/destructure, :variadic false, :file "out/cljs/core.cljc", :end-column 23, :method-params ([bindings]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 610, :end-line 610, :max-fixed-arity 1, :fn-var true, :arglists (quote ([bindings]))}, defmulti {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 2553, :column 16, :end-line 2553, :end-column 24, :macro true, :arglists (quote ([mm-name & options])), :doc "Creates a new multimethod with the associated dispatch function.\n  The docstring and attribute-map are optional.\n\n  Options are key-value pairs and may be one of:\n    :default    the default dispatch value, defaults to :default\n    :hierarchy  the isa? hierarchy to use for dispatching\n                defaults to the global hierarchy", :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env mm-name options)], :arglists ([&form &env mm-name & options]), :arglists-meta (nil)}}, :name cljs.core$macros/defmulti, :variadic true, :file "out/cljs/core.cljc", :end-column 24, :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env mm-name options)], :arglists ([&form &env mm-name & options]), :arglists-meta (nil)}, :method-params [(&form &env mm-name options)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 2553, :macro true, :end-line 2553, :max-fixed-arity 3, :fn-var true, :arglists ([&form &env mm-name & options]), :doc "Creates a new multimethod with the associated dispatch function.\n  The docstring and attribute-map are optional.\n\n  Options are key-value pairs and may be one of:\n    :default    the default dispatch value, defaults to :default\n    :hierarchy  the isa? hierarchy to use for dispatching\n                defaults to the global hierarchy"}, str {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 805, :column 16, :end-line 805, :end-column 19, :macro true, :arglists (quote ([& xs])), :top-fn {:variadic true, :max-fixed-arity 2, :method-params [(&form &env xs)], :arglists ([&form &env & xs]), :arglists-meta (nil)}}, :name cljs.core$macros/str, :variadic true, :file "out/cljs/core.cljc", :end-column 19, :top-fn {:variadic true, :max-fixed-arity 2, :method-params [(&form &env xs)], :arglists ([&form &env & xs]), :arglists-meta (nil)}, :method-params [(&form &env xs)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 805, :macro true, :end-line 805, :max-fixed-arity 2, :fn-var true, :arglists ([&form &env & xs])}, coercive-= {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 867, :column 16, :end-line 867, :end-column 26, :macro true, :arglists (quote ([x y]))}, :name cljs.core$macros/coercive-=, :variadic false, :file "out/cljs/core.cljc", :end-column 26, :method-params ([&form &env x y]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 867, :macro true, :end-line 867, :max-fixed-arity 4, :fn-var true, :arglists (quote ([x y]))}, hash-map {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 2445, :column 16, :end-line 2445, :end-column 24, :macro true, :arglists (quote ([] [& kvs])), :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([&form &env]), :arglists ([&form &env] [&form &env & kvs]), :arglists-meta (nil nil)}}, :name cljs.core$macros/hash-map, :variadic true, :file "out/cljs/core.cljc", :end-column 24, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([&form &env]), :arglists ([&form &env] [&form &env & kvs]), :arglists-meta (nil nil)}, :method-params ([&form &env]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2445, :macro true, :end-line 2445, :max-fixed-arity 2, :fn-var true, :arglists ([&form &env] [&form &env & kvs])}, if-let {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 335, :column 19, :end-line 335, :end-column 25, :macro true, :arglists (quote ([bindings then] [bindings then else & oldform])), :doc "bindings => binding-form test\n\n     If test is true, evaluates then with binding-form bound to the value of\n     test, if not, yields else", :top-fn {:variadic true, :max-fixed-arity 5, :method-params ([&form &env bindings then]), :arglists ([&form &env bindings then] [&form &env bindings then else & oldform]), :arglists-meta (nil nil)}}, :name cljs.core$macros/if-let, :variadic true, :file "out/cljs/core.cljc", :end-column 25, :top-fn {:variadic true, :max-fixed-arity 5, :method-params ([&form &env bindings then]), :arglists ([&form &env bindings then] [&form &env bindings then else & oldform]), :arglists-meta (nil nil)}, :method-params ([&form &env bindings then]), :protocol-impl nil, :arglists-meta (nil nil), :column 4, :line 335, :macro true, :end-line 335, :max-fixed-arity 5, :fn-var true, :arglists ([&form &env bindings then] [&form &env bindings then else & oldform]), :doc "bindings => binding-form test\n\n     If test is true, evaluates then with binding-form bound to the value of\n     test, if not, yields else"}, add-ifn-methods {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 1419, :column 13, :end-line 1419, :end-column 28, :private true, :arglists (quote ([type type-sym [f & meths :as form]]))}, :private true, :name cljs.core$macros/add-ifn-methods, :variadic false, :file "out/cljs/core.cljc", :end-column 28, :method-params ([type type-sym p__14001]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1419, :end-line 1419, :max-fixed-arity 3, :fn-var true, :arglists (quote ([type type-sym [f & meths :as form]]))}, false? {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 925, :column 16, :end-line 925, :end-column 22, :macro true, :arglists (quote ([x]))}, :name cljs.core$macros/false?, :variadic false, :file "out/cljs/core.cljc", :end-column 22, :method-params ([&form &env x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 925, :macro true, :end-line 925, :max-fixed-arity 3, :fn-var true, :arglists (quote ([x]))}, case {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 2161, :column 16, :end-line 2161, :end-column 20, :macro true, :arglists (quote ([e & clauses])), :doc "Takes an expression, and a set of clauses.\n\n  Each clause can take the form of either:\n\n  test-constant result-expr\n\n  (test-constant1 ... test-constantN)  result-expr\n\n  The test-constants are not evaluated. They must be compile-time\n  literals, and need not be quoted.  If the expression is equal to a\n  test-constant, the corresponding result-expr is returned. A single\n  default expression can follow the clauses, and its value will be\n  returned if no clause matches. If no default expression is provided\n  and no clause matches, an Error is thrown.\n\n  Unlike cond and condp, case does a constant-time dispatch, the\n  clauses are not considered sequentially.  All manner of constant\n  expressions are acceptable in case, including numbers, strings,\n  symbols, keywords, and (ClojureScript) composites thereof. Note that since\n  lists are used to group multiple constants that map to the same\n  expression, a vector can be used to match a list if needed. The\n  test-constants need not be all of the same type.", :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env e clauses)], :arglists ([&form &env e & clauses]), :arglists-meta (nil)}}, :name cljs.core$macros/case, :variadic true, :file "out/cljs/core.cljc", :end-column 20, :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env e clauses)], :arglists ([&form &env e & clauses]), :arglists-meta (nil)}, :method-params [(&form &env e clauses)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 2161, :macro true, :end-line 2161, :max-fixed-arity 3, :fn-var true, :arglists ([&form &env e & clauses]), :doc "Takes an expression, and a set of clauses.\n\n  Each clause can take the form of either:\n\n  test-constant result-expr\n\n  (test-constant1 ... test-constantN)  result-expr\n\n  The test-constants are not evaluated. They must be compile-time\n  literals, and need not be quoted.  If the expression is equal to a\n  test-constant, the corresponding result-expr is returned. A single\n  default expression can follow the clauses, and its value will be\n  returned if no clause matches. If no default expression is provided\n  and no clause matches, an Error is thrown.\n\n  Unlike cond and condp, case does a constant-time dispatch, the\n  clauses are not considered sequentially.  All manner of constant\n  expressions are acceptable in case, including numbers, strings,\n  symbols, keywords, and (ClojureScript) composites thereof. Note that since\n  lists are used to group multiple constants that map to the same\n  expression, a vector can be used to match a list if needed. The\n  test-constants need not be all of the same type."}, exists? {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 932, :column 16, :end-line 932, :end-column 23, :macro true, :arglists (quote ([x])), :doc "Return true if argument exists, analogous to usage of typeof operator\n   in JavaScript."}, :name cljs.core$macros/exists?, :variadic false, :file "out/cljs/core.cljc", :end-column 23, :method-params ([&form &env x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 932, :macro true, :end-line 932, :max-fixed-arity 3, :fn-var true, :arglists (quote ([x])), :doc "Return true if argument exists, analogous to usage of typeof operator\n   in JavaScript."}, bit-not {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 1116, :column 31, :end-line 1116, :end-column 38, :cljs.analyzer/numeric true, :macro true, :arglists (quote ([x]))}, :name cljs.core$macros/bit-not, :variadic false, :file "out/cljs/core.cljc", :end-column 38, :method-params ([&form &env x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1116, :macro true, :end-line 1116, :max-fixed-arity 3, :fn-var true, :arglists (quote ([x])), :cljs.analyzer/numeric true}, byte {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 987, :column 16, :end-line 987, :end-column 20, :macro true, :arglists (quote ([x]))}, :name cljs.core$macros/byte, :variadic false, :file "out/cljs/core.cljc", :end-column 20, :method-params ([&form &env x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 987, :macro true, :end-line 987, :max-fixed-arity 3, :fn-var true, :arglists (quote ([x]))}, max {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 1101, :column 31, :end-line 1101, :end-column 34, :cljs.analyzer/numeric true, :macro true, :arglists (quote ([x] [x y] [x y & more])), :top-fn {:variadic true, :max-fixed-arity 4, :method-params ([&form &env x] [&form &env x y]), :arglists ([&form &env x] [&form &env x y] [&form &env x y & more]), :arglists-meta (nil nil nil)}}, :name cljs.core$macros/max, :variadic true, :file "out/cljs/core.cljc", :end-column 34, :top-fn {:variadic true, :max-fixed-arity 4, :method-params ([&form &env x] [&form &env x y]), :arglists ([&form &env x] [&form &env x y] [&form &env x y & more]), :arglists-meta (nil nil nil)}, :method-params ([&form &env x] [&form &env x y]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 1101, :macro true, :end-line 1101, :max-fixed-arity 4, :fn-var true, :arglists ([&form &env x] [&form &env x y] [&form &env x y & more]), :cljs.analyzer/numeric true}, == {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 1081, :column 31, :end-line 1081, :end-column 33, :cljs.analyzer/numeric true, :macro true, :arglists (quote ([x] [x y] [x y & more])), :top-fn {:variadic true, :max-fixed-arity 4, :method-params ([&form &env x] [&form &env x y]), :arglists ([&form &env x] [&form &env x y] [&form &env x y & more]), :arglists-meta (nil nil nil)}}, :name cljs.core$macros/==, :variadic true, :file "out/cljs/core.cljc", :end-column 33, :top-fn {:variadic true, :max-fixed-arity 4, :method-params ([&form &env x] [&form &env x y]), :arglists ([&form &env x] [&form &env x y] [&form &env x y & more]), :arglists-meta (nil nil nil)}, :method-params ([&form &env x] [&form &env x y]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 1081, :macro true, :end-line 1081, :max-fixed-arity 4, :fn-var true, :arglists ([&form &env x] [&form &env x y] [&form &env x y & more]), :cljs.analyzer/numeric true}, lazy-cat {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 2670, :column 16, :end-line 2670, :end-column 24, :macro true, :arglists (quote ([& colls])), :doc "Expands to code which yields a lazy sequence of the concatenation\n  of the supplied colls.  Each coll expr is not evaluated until it is\n  needed.\n\n  (lazy-cat xs ys zs) === (concat (lazy-seq xs) (lazy-seq ys) (lazy-seq zs))", :top-fn {:variadic true, :max-fixed-arity 2, :method-params [(&form &env colls)], :arglists ([&form &env & colls]), :arglists-meta (nil)}}, :name cljs.core$macros/lazy-cat, :variadic true, :file "out/cljs/core.cljc", :end-column 24, :top-fn {:variadic true, :max-fixed-arity 2, :method-params [(&form &env colls)], :arglists ([&form &env & colls]), :arglists-meta (nil)}, :method-params [(&form &env colls)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 2670, :macro true, :end-line 2670, :max-fixed-arity 2, :fn-var true, :arglists ([&form &env & colls]), :doc "Expands to code which yields a lazy sequence of the concatenation\n  of the supplied colls.  Each coll expr is not evaluated until it is\n  needed.\n\n  (lazy-cat xs ys zs) === (concat (lazy-seq xs) (lazy-seq ys) (lazy-seq zs))"}, comment {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 151, :column 19, :end-line 151, :end-column 26, :macro true, :arglists (quote ([& body])), :doc "Ignores body, yields nil", :top-fn {:variadic true, :max-fixed-arity 2, :method-params [(&form &env body)], :arglists ([&form &env & body]), :arglists-meta (nil)}}, :name cljs.core$macros/comment, :variadic true, :file "out/cljs/core.cljc", :end-column 26, :top-fn {:variadic true, :max-fixed-arity 2, :method-params [(&form &env body)], :arglists ([&form &env & body]), :arglists-meta (nil)}, :method-params [(&form &env body)], :protocol-impl nil, :arglists-meta (nil), :column 4, :line 151, :macro true, :end-line 151, :max-fixed-arity 2, :fn-var true, :arglists ([&form &env & body]), :doc "Ignores body, yields nil"}, warn-and-update-protocol {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 1329, :column 13, :end-line 1329, :end-column 37, :private true, :arglists (quote ([p type env]))}, :private true, :name cljs.core$macros/warn-and-update-protocol, :variadic false, :file "out/cljs/core.cljc", :end-column 37, :method-params ([p type env]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1329, :end-line 1329, :max-fixed-arity 3, :fn-var true, :arglists (quote ([p type env]))}, copy-arguments {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 2785, :column 16, :end-line 2785, :end-column 30, :macro true, :arglists (quote ([dest]))}, :name cljs.core$macros/copy-arguments, :variadic false, :file "out/cljs/core.cljc", :end-column 30, :method-params ([&form &env dest]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2785, :macro true, :end-line 2785, :max-fixed-arity 3, :fn-var true, :arglists (quote ([dest]))}, unsafe-cast {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 911, :column 16, :end-line 911, :end-column 27, :macro true, :arglists (quote ([t x])), :doc "EXPERIMENTAL: Subject to change. Unsafely cast a value to a different type."}, :name cljs.core$macros/unsafe-cast, :variadic false, :file "out/cljs/core.cljc", :end-column 27, :method-params ([&form &env t x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 911, :macro true, :end-line 911, :max-fixed-arity 4, :fn-var true, :arglists (quote ([t x])), :doc "EXPERIMENTAL: Subject to change. Unsafely cast a value to a different type."}, type-hint-multi-arity-sigs {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 1521, :column 13, :end-line 1521, :end-column 39, :private true, :arglists (quote ([type-sym sigs]))}, :private true, :name cljs.core$macros/type-hint-multi-arity-sigs, :variadic false, :file "out/cljs/core.cljc", :end-column 39, :method-params ([type-sym sigs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1521, :end-line 1521, :max-fixed-arity 2, :fn-var true, :arglists (quote ([type-sym sigs]))}, defrecord {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 1809, :column 16, :end-line 1809, :end-column 25, :macro true, :arglists (quote ([rsym fields & impls])), :doc "(defrecord name [fields*]  options* specs*)\n\n  Currently there are no options.\n\n  Each spec consists of a protocol or interface name followed by zero\n  or more method bodies:\n\n  protocol-or-Object\n  (methodName [args*] body)*\n\n  The record will have the (immutable) fields named by\n  fields, which can have type hints. Protocols and methods\n  are optional. The only methods that can be supplied are those\n  declared in the protocols.  Note that method bodies are\n  not closures, the local environment includes only the named fields,\n  and those fields can be accessed directly.\n\n  Method definitions take the form:\n\n  (methodname [args*] body)\n\n  The argument and return types can be hinted on the arg and\n  methodname symbols. If not supplied, they will be inferred, so type\n  hints should be reserved for disambiguation.\n\n  Methods should be supplied for all methods of the desired\n  protocol(s). You can also define overrides for\n  methods of Object. Note that a parameter must be supplied to\n  correspond to the target object ('this' in JavaScript parlance). Note also\n  that recur calls to the method head should *not* pass the target object, it\n  will be supplied automatically and can not be substituted.\n\n  In the method bodies, the (unqualified) name can be used to name the\n  class (for calls to new, instance? etc).\n\n  The type will have implementations of several ClojureScript\n  protocol generated automatically: IMeta/IWithMeta (metadata support) and\n  IMap, etc.\n\n  In addition, defrecord will define type-and-value-based =,\n  and will define ClojureScript IHash and IEquiv.\n\n  Two constructors will be defined, one taking the designated fields\n  followed by a metadata map (nil for none) and an extension field\n  map (nil for none), and one taking only the fields (using nil for\n  meta and extension fields). Note that the field names __meta\n  and __extmap are currently reserved and should not be used when\n  defining your own records.\n\n  Given (defrecord TypeName ...), two factory functions will be\n  defined: ->TypeName, taking positional parameters for the fields,\n  and map->TypeName, taking a map of keywords to field values.", :top-fn {:variadic true, :max-fixed-arity 4, :method-params [(&form &env rsym fields impls)], :arglists ([&form &env rsym fields & impls]), :arglists-meta (nil)}}, :name cljs.core$macros/defrecord, :variadic true, :file "out/cljs/core.cljc", :end-column 25, :top-fn {:variadic true, :max-fixed-arity 4, :method-params [(&form &env rsym fields impls)], :arglists ([&form &env rsym fields & impls]), :arglists-meta (nil)}, :method-params [(&form &env rsym fields impls)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 1809, :macro true, :end-line 1809, :max-fixed-arity 4, :fn-var true, :arglists ([&form &env rsym fields & impls]), :doc "(defrecord name [fields*]  options* specs*)\n\n  Currently there are no options.\n\n  Each spec consists of a protocol or interface name followed by zero\n  or more method bodies:\n\n  protocol-or-Object\n  (methodName [args*] body)*\n\n  The record will have the (immutable) fields named by\n  fields, which can have type hints. Protocols and methods\n  are optional. The only methods that can be supplied are those\n  declared in the protocols.  Note that method bodies are\n  not closures, the local environment includes only the named fields,\n  and those fields can be accessed directly.\n\n  Method definitions take the form:\n\n  (methodname [args*] body)\n\n  The argument and return types can be hinted on the arg and\n  methodname symbols. If not supplied, they will be inferred, so type\n  hints should be reserved for disambiguation.\n\n  Methods should be supplied for all methods of the desired\n  protocol(s). You can also define overrides for\n  methods of Object. Note that a parameter must be supplied to\n  correspond to the target object ('this' in JavaScript parlance). Note also\n  that recur calls to the method head should *not* pass the target object, it\n  will be supplied automatically and can not be substituted.\n\n  In the method bodies, the (unqualified) name can be used to name the\n  class (for calls to new, instance? etc).\n\n  The type will have implementations of several ClojureScript\n  protocol generated automatically: IMeta/IWithMeta (metadata support) and\n  IMap, etc.\n\n  In addition, defrecord will define type-and-value-based =,\n  and will define ClojureScript IHash and IEquiv.\n\n  Two constructors will be defined, one taking the designated fields\n  followed by a metadata map (nil for none) and an extension field\n  map (nil for none), and one taking only the fields (using nil for\n  meta and extension fields). Note that the field names __meta\n  and __extmap are currently reserved and should not be used when\n  defining your own records.\n\n  Given (defrecord TypeName ...), two factory functions will be\n  defined: ->TypeName, taking positional parameters for the fields,\n  and map->TypeName, taking a map of keywords to field values."}, make-array {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 2397, :column 16, :end-line 2397, :end-column 26, :macro true, :arglists (quote ([size] [type size] [type size & more-sizes])), :top-fn {:variadic true, :max-fixed-arity 4, :method-params ([&form &env size] [&form &env type size]), :arglists ([&form &env size] [&form &env type size] [&form &env type size & more-sizes]), :arglists-meta (nil nil nil)}}, :name cljs.core$macros/make-array, :variadic true, :file "out/cljs/core.cljc", :end-column 26, :top-fn {:variadic true, :max-fixed-arity 4, :method-params ([&form &env size] [&form &env type size]), :arglists ([&form &env size] [&form &env type size] [&form &env type size & more-sizes]), :arglists-meta (nil nil nil)}, :method-params ([&form &env size] [&form &env type size]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 2397, :macro true, :end-line 2397, :max-fixed-arity 4, :fn-var true, :arglists ([&form &env size] [&form &env type size] [&form &env type size & more-sizes])}, unchecked-negate-int {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 1028, :column 31, :end-line 1028, :end-column 51, :cljs.analyzer/numeric true, :macro true, :arglists (quote ([x]))}, :name cljs.core$macros/unchecked-negate-int, :variadic false, :file "out/cljs/core.cljc", :end-column 51, :method-params ([&form &env x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1028, :macro true, :end-line 1028, :max-fixed-arity 3, :fn-var true, :arglists (quote ([x])), :cljs.analyzer/numeric true}, simple-test-expr? {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 814, :column 13, :end-line 814, :end-column 30, :private true, :arglists (quote ([env ast]))}, :private true, :name cljs.core$macros/simple-test-expr?, :variadic false, :file "out/cljs/core.cljc", :end-column 30, :method-params ([env ast]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 814, :end-line 814, :max-fixed-arity 2, :fn-var true, :arglists (quote ([env ast]))}, unchecked-inc {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 1013, :column 31, :end-line 1013, :end-column 44, :cljs.analyzer/numeric true, :macro true, :arglists (quote ([x]))}, :name cljs.core$macros/unchecked-inc, :variadic false, :file "out/cljs/core.cljc", :end-column 44, :method-params ([&form &env x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1013, :macro true, :end-line 1013, :max-fixed-arity 3, :fn-var true, :arglists (quote ([x])), :cljs.analyzer/numeric true}, and {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 819, :column 16, :end-line 819, :end-column 19, :macro true, :arglists (quote ([] [x] [x & next])), :doc "Evaluates exprs one at a time, from left to right. If a form\n  returns logical false (nil or false), and returns that value and\n  doesn't evaluate any of the other expressions, otherwise it returns\n  the value of the last expr. (and) returns true.", :top-fn {:variadic true, :max-fixed-arity 3, :method-params ([&form &env] [&form &env x]), :arglists ([&form &env] [&form &env x] [&form &env x & next]), :arglists-meta (nil nil nil)}}, :name cljs.core$macros/and, :variadic true, :file "out/cljs/core.cljc", :end-column 19, :top-fn {:variadic true, :max-fixed-arity 3, :method-params ([&form &env] [&form &env x]), :arglists ([&form &env] [&form &env x] [&form &env x & next]), :arglists-meta (nil nil nil)}, :method-params ([&form &env] [&form &env x]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 819, :macro true, :end-line 819, :max-fixed-arity 3, :fn-var true, :arglists ([&form &env] [&form &env x] [&form &env x & next]), :doc "Evaluates exprs one at a time, from left to right. If a form\n  returns logical false (nil or false), and returns that value and\n  doesn't evaluate any of the other expressions, otherwise it returns\n  the value of the last expr. (and) returns true."}, number? {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 957, :column 16, :end-line 957, :end-column 23, :macro true, :arglists (quote ([x]))}, :name cljs.core$macros/number?, :variadic false, :file "out/cljs/core.cljc", :end-column 23, :method-params ([&form &env x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 957, :macro true, :end-line 957, :max-fixed-arity 3, :fn-var true, :arglists (quote ([x]))}, assoc-test {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 2139, :column 13, :end-line 2139, :end-column 23, :private true, :arglists (quote ([m test expr env]))}, :private true, :name cljs.core$macros/assoc-test, :variadic false, :file "out/cljs/core.cljc", :end-column 23, :method-params ([m test expr env]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2139, :end-line 2139, :max-fixed-arity 4, :fn-var true, :arglists (quote ([m test expr env]))}, js-comment {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 897, :column 16, :end-line 897, :end-column 26, :macro true, :arglists (quote ([comment])), :doc "Emit a top-level JavaScript multi-line comment. New lines will create a\n  new comment line. Comment block will be preceded and followed by a newline"}, :name cljs.core$macros/js-comment, :variadic false, :file "out/cljs/core.cljc", :end-column 26, :method-params ([&form &env comment]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 897, :macro true, :end-line 897, :max-fixed-arity 3, :fn-var true, :arglists (quote ([comment])), :doc "Emit a top-level JavaScript multi-line comment. New lines will create a\n  new comment line. Comment block will be preceded and followed by a newline"}, validate-impls {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 1491, :column 13, :end-line 1491, :end-column 27, :private true, :arglists (quote ([env impls]))}, :private true, :name cljs.core$macros/validate-impls, :variadic false, :file "out/cljs/core.cljc", :end-column 27, :method-params ([env impls]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1491, :end-line 1491, :max-fixed-arity 2, :fn-var true, :arglists (quote ([env impls]))}, symbol? {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 960, :column 16, :end-line 960, :end-column 23, :macro true, :arglists (quote ([x]))}, :name cljs.core$macros/symbol?, :variadic false, :file "out/cljs/core.cljc", :end-column 23, :method-params ([&form &env x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 960, :macro true, :end-line 960, :max-fixed-arity 3, :fn-var true, :arglists (quote ([x]))}, when-some {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 521, :column 19, :end-line 521, :end-column 28, :macro true, :arglists (quote ([bindings & body])), :doc "bindings => binding-form test\n\n      When test is not nil, evaluates body with binding-form bound to the\n      value of test", :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env bindings body)], :arglists ([&form &env bindings & body]), :arglists-meta (nil)}}, :name cljs.core$macros/when-some, :variadic true, :file "out/cljs/core.cljc", :end-column 28, :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env bindings body)], :arglists ([&form &env bindings & body]), :arglists-meta (nil)}, :method-params [(&form &env bindings body)], :protocol-impl nil, :arglists-meta (nil), :column 4, :line 521, :macro true, :end-line 521, :max-fixed-arity 3, :fn-var true, :arglists ([&form &env bindings & body]), :doc "bindings => binding-form test\n\n      When test is not nil, evaluates body with binding-form bound to the\n      value of test"}, unchecked-char {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 993, :column 16, :end-line 993, :end-column 30, :macro true, :arglists (quote ([x]))}, :name cljs.core$macros/unchecked-char, :variadic false, :file "out/cljs/core.cljc", :end-column 30, :method-params ([&form &env x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 993, :macro true, :end-line 993, :max-fixed-arity 3, :fn-var true, :arglists (quote ([x]))}, ->> {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 117, :column 19, :end-line 117, :end-column 22, :macro true, :arglists (quote ([x & forms])), :doc "Threads the expr through the forms. Inserts x as the\n     last item in the first form, making a list of it if it is not a\n     list already. If there are more forms, inserts the first form as the\n     last item in second form, etc.", :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env x forms)], :arglists ([&form &env x & forms]), :arglists-meta (nil)}}, :name cljs.core$macros/->>, :variadic true, :file "out/cljs/core.cljc", :end-column 22, :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env x forms)], :arglists ([&form &env x & forms]), :arglists-meta (nil)}, :method-params [(&form &env x forms)], :protocol-impl nil, :arglists-meta (nil), :column 4, :line 117, :macro true, :end-line 117, :max-fixed-arity 3, :fn-var true, :arglists ([&form &env x & forms]), :doc "Threads the expr through the forms. Inserts x as the\n     last item in the first form, making a list of it if it is not a\n     list already. If there are more forms, inserts the first form as the\n     last item in second form, etc."}, js-inline-comment {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 917, :column 16, :end-line 917, :end-column 33, :macro true, :arglists (quote ([comment])), :doc "Emit an inline JavaScript comment."}, :name cljs.core$macros/js-inline-comment, :variadic false, :file "out/cljs/core.cljc", :end-column 33, :method-params ([&form &env comment]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 917, :macro true, :end-line 917, :max-fixed-arity 3, :fn-var true, :arglists (quote ([comment])), :doc "Emit an inline JavaScript comment."}, dt->et {:protocol-inline nil, :meta {:file "/Users/clumsyjedi/workspace/clack/out/cljs/core.cljc", :line 1606, :column 12, :end-line 1606, :end-column 18, :arglists (quote ([type specs fields] [type specs fields inline])), :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([type specs fields] [type specs fields inline]), :arglists ([type specs fields] [type specs fields inline]), :arglists-meta (nil nil)}}, :name cljs.core$macros/dt->et, :variadic false, :file "out/cljs/core.cljc", :end-column 18, :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([type specs fields] [type specs fields inline]), :arglists ([type specs fields] [type specs fields inline]), :arglists-meta (nil nil)}, :method-params ([type specs fields] [type specs fields inline]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1606, :end-line 1606, :max-fixed-arity 4, :fn-var true, :arglists ([type specs fields] [type specs fields inline])}}, :require-macros {core cljs.core, cljs.core cljs.core, cljs.support cljs.support}, :cljs.analyzer/constants {:seen #{this__14100__auto__ cljs.core$macros/or m__14140__auto__ cljs.core/-rest ITransientAssociative .-cljs$lang$ctorPrWriter & seq k__14112__auto__ c__14444__auto__ self__ case* :extending-base-js-type cljs.core$macros/- cljs.core/rest -with-meta :cljs.analyzer/namespaces defrecord* -prototype cljs.core$macros/zero? js/Function this__14108__auto__ -iterator this__14104__auto__ cljs.core/str cljs.core$macros/extend-type cljs.core/PersistentHashMap try Object ILookup cljs.core/MultiFn end__14591__auto__ cljs.core$macros/nil? -assoc js/goog iterys__14274__auto__ IKVReduce :js .-fqn -conj cljs.core$macros/defonce cljs.core$macros/bit-and ITransientMap ___14590__auto__ cljs.core$macros/identical? :fname cljs.core$macros/instance? boolean opts__14120__auto__ cljs.core/PersistentHashSet. cljs.core/specify! cljs.core/pr-sequential-writer :let xs__13398__auto__ cljs.core$macros/dotimes and__13551__auto__ object cljs.core/vector? argseq__14696__auto__ cljs.core/PersistentArrayMap :cljs.core$macros/not-found x__14613__auto__ :invalid-protocol-symbol this-as cljs.core/= .. -clone opt__14085__auto__ -count cljs.core/MultiFn. cljs.core$macros// cljs.core$macros/vector cljs.core/-assoc :pre cljs.core$macros/bit-or var_args cljs.core$macros/array cljs.core/-write .-constructor cljs.core$macros/assert :instance method-table__14566__auto__ cljs.core/IndexedSeq IIndexed cljs.core/-deref :private :extend IPrintWithWriter :else cljs.core/pr-writer this__14129__auto__ :when IVector IIterable cljs.core$macros/loop cljs.core/-iterator elapsed__14592__auto__ cljs.core$macros/>= :protocol-duped-method x__13585__auto__ :protocol-symbol .toFixed len__14693__auto__ :protocol .apply cljs.core/count cached-hierarchy__14569__auto__ nodeGlobalRequire cljs.core/hash-map goog/typeOf or__13565__auto__ cljs.core/reduce cljs.core/seq js/Date. cljs.core/chunk-first cljs.core/IFn cljs.core$macros/cond cljs.core/get-global-hierarchy cljs.core/apply args :locals cljs.core$macros/condp finally cljs.core/Keyword :method cljs.core/prn IMeta :default apply-to -lookup ICloneable cljs.core/aclone loop* :protocols :ns -pr-writer cljs.core$macros/binding cljs.core/chunk start__14586__auto__ argc :def-emits-var INext :name ICounted IMapEntry :as cljs.core/es6-iterator &form cljs.core$macros/with-redefs cljs.core$macros/inc :nonchar cljs.core/dissoc IStack :variadic cljs.core/keyword-identical? cljs.core/*print-newline* cljs.core/Delay cljs.core/LazySeq cljs.core/chunk-rest :constant cljs.core/atom IReversible :or cljs.core$macros/coercive-= cljs.core$macros/str cljs.core$macros/if-let :file cljs.core/concat -> cljs.core$macros/list cljs.core$macros/+ :end-column cljs.core$macros/aset __hash x__14476__auto__ IHash cljs.core$macros/exists? :top-fn cljs.core$macros/== IEquiv cljs.core$macros/max cljs.core$macros/case cljs.core$macros/copy-arguments js/Boolean ITransientVector fs__14275__auto__ RecordIter. cljs.core/native-satisfies? .append .concat js/String do __meta keyval__14122__auto__ :method-params call number IEditableCollection cljs.core/contains? k__14114__auto__ :op :current-symbol cljs.core/into :>> a__14551__auto__ :cljs.analyzer/type this__14083__auto__ cljs.core/-conj letfn* :protocol-with-variadic-method c__14276__auto__ if cljs.core/with-meta cljs.core$macros/unchecked-inc cljs.core$macros/and IReset :arglists-meta IEmptyableCollection :cljs.analyzer/protocol-inline % IRecord new IDerefWithTimeout a__14550__auto__ dims__14461__auto__ x__13862__auto__ :anonymous ISet IPending :column cljs.core/not-native .getTime :cljs.analyzer/protocol-impl default .fromArray cljs.core$macros/->> cljs.core/-first c__13584__auto__ cljs.core$macros/when-first this__14106__auto__ cljs.core/PersistentVector -equiv :internal-ctor cljs.core/ISeq cljs.core$macros/unsafe-bit-and .-prototype cljs.core/List ret__14589__auto__ .push args__14695__auto__ cljs.core/-add-method println cljs.core/make-array ISwap size__14277__auto__ .-cljs$lang$ctorStr cljs.core/get .fromArrays :positional hash-imap cljs.core/cond this__14113__auto__ :factory :const INamed this__14099__auto__ cljs.core$macros/aget deftype* IReduce let* cljs.core/chunk-append js/Array ITransientCollection cljs.core/-nth :methods not-native js* :undeclared-protocol-symbol :undeclared cljs.core/IMeta cljs.core$macros/coercive-not temp__13489__auto__ cljs.core$macros/dec :line cljs.core/not-empty x__14139__auto__ sb__14612__auto__ :var cljs.core/PersistentArrayMap. fn* :protocol-info -cljs$lang$applyTo cljs.core$macros/caching-hash recur cljs.core/-vreset! ret__14587__auto__ :macro cljs.core$macros/this-as cljs.core/symbol :deprecation-nowarn cljs.core$macros/< js/Error. .-getBasis :deprecated .-cljs$lang$type cljs.core/missing-protocol -meta IMap array :defs ISeq cljs.core/-lookup &env string :declared cljs.core/nth prefer-table__14567__auto__ cljs.core/PersistentHashSet writer__14084__auto__ method-cache__14568__auto__ IMultiFn .slice goog/define temp__13355__auto__ this__14098__auto__ IAssociative function cljs$core$IFn$_invoke$arity$variadic cljs.core$macros/implements? ISeqable :end-line cljs.core$macros/alength :cljs.analyzer/no-resolve ISequential cljs.core$macros/if-not :invoke :print-fn IChunkedSeq i__14694__auto__ cljs.core/next :post this__14102__auto__ cljs.core$macros/bit-xor -dissoc IAtom cljs.core$macros/when-let map-> cljs.core$macros/mask x__13787__auto__ IWatchable :no-such-method cljs.core$macros/coercive-boolean pr-pair__14121__auto__ cljs.core/chunk-cons iter__14278__auto__ cljs.core/*print-fn* cljs.core$macros/deftype ITransientSet cljs.core/not cljs.core$macros/* :max-fixed-arity cljs.core$macros/min set! this__14627__auto__ cljs.core/cons :tag n__14552__auto__ cljs.core$macros/<= cljs.core/assoc -cljs$lang$maxFixedArity cljs.core$macros/if-some :dot :protocol-deprecated y__13774__auto__ cljs.core$macros/-> . IWithMeta var :mutable cljs.core/system-time cljs.core/chunk-buffer quote cljs.core/Symbol ICollection :while ASeq cljs.core$macros/lazy-seq cljs.core$macros/js-delete IFn :arglists :skip-protocol-flag cljs.core$macros/let temp__13475__auto__ cljs.core$macros/fn start__14588__auto__ :impls :hierarchy entry__14110__auto__ p__14223__auto__ js/Object this__14103__auto__ cljs.core$macros/bit-and-not js/Array. IComparable :doc -cljs$lang$macro cljs.core$macros/when-not cljs.core/PersistentVector. else__14107__auto__ cljs.core/clone x__13773__auto__ h__13861__auto__ apply cljs.core/first :protocol-multiple-impls cljs.core$macros/js-this i__14463__auto__ :jsdoc IChunkedNext js/Number cljs.core/equiv-map cljs.core$macros/js-arguments :protocol-invalid-method :invalid-arity :extend-type-invalid-method-shape .-EMPTY cljs.core$macros/keyword? temp__13409__auto__ cljs.core/IWithMeta IWriter :suggested-symbol :map cljs.core/list __extmap cljs.core$macros/when cljs.core$macros/> this__14118__auto__ this__14116__auto__ IDeref ISorted *unchecked-if* throw writer__14119__auto__ js/goog.string.StringBuffer. y__13788__auto__ .-cljs$lang$ctorPrSeq argseq__14712__auto__ k__14105__auto__ other__14101__auto__ cljs.core$macros/defn -hash this__14111__auto__ .-EMPTY-NODE def this__14109__auto__ hierarchy__14570__auto__ writer__14130__auto__ cljs.core$macros/declare cljs.core/chunked-seq? IList f cljs.core$macros/mod dimarray__14462__auto__ cljs.core/ITER_SYMBOL .-call -seq}, :order [. .. if cljs.core/cond do def :declared cljs.core$macros/let cljs.core$macros/extend-type :pre :post % cljs.core$macros/assert fn* cljs.core$macros/defn :private cljs.core$macros/if-let temp__13355__auto__ cljs.core$macros/if-not cljs.core/not letfn* cljs.core$macros/fn cljs.core$macros/when-let xs__13398__auto__ cljs.core/seq cljs.core/first temp__13409__auto__ cljs.core$macros/when cljs.core$macros/loop recur cljs.core$macros/-> cljs.core$macros/->> cljs.core$macros/nil? cljs.core$macros/if-some temp__13475__auto__ temp__13489__auto__ &form cljs.core$macros/when-not cljs.core$macros/exists? & :as :else cljs.core/next cljs.core/nth :or cljs.core$macros/implements? cljs.core/ISeq cljs.core/apply cljs.core/hash-map quote cljs.core/get cljs.core$macros/declare js* goog/define let* loop* IFn ICounted IEmptyableCollection ICollection IIndexed ASeq ISeq INext ILookup IAssociative IMap IMapEntry ISet IStack IVector IDeref IDerefWithTimeout IMeta IWithMeta IReduce IKVReduce IEquiv IHash ISeqable ISequential IList IRecord IReversible ISorted IPrintWithWriter IWriter IPending IWatchable IEditableCollection ITransientCollection ITransientAssociative ITransientMap ITransientVector ITransientSet IMultiFn IChunkedSeq IChunkedNext IComparable INamed ICloneable IAtom IReset ISwap :tag boolean :js :constant :var :invoke :dot :op seq and__13551__auto__ cljs.core$macros/and or__13565__auto__ cljs.core$macros/or cljs.core$macros/coercive-= :cljs.analyzer/no-resolve c__13584__auto__ x__13585__auto__ cljs.core$macros/instance? cljs.core/Symbol cljs.core/Keyword cljs.core$macros/+ cljs.core$macros/dec cljs.core$macros// cljs.core$macros/inc cljs.core$macros/* cljs.core$macros/- cljs.core$macros/mod cljs.core$macros/< cljs.core$macros/<= cljs.core$macros/> cljs.core$macros/>= cljs.core$macros/== x__13773__auto__ y__13774__auto__ cljs.core$macros/max x__13787__auto__ y__13788__auto__ cljs.core$macros/min cljs.core$macros/bit-and cljs.core$macros/unsafe-bit-and cljs.core$macros/bit-or cljs.core$macros/bit-xor cljs.core$macros/bit-and-not cljs.core$macros/mask h__13861__auto__ set! x__13862__auto__ object string number array function default js/Boolean js/String js/Array js/Object js/Number js/Function :anonymous :locals :name :ns cljs.core$macros/deftype cljs.core/IWithMeta -with-meta new cljs.core/IMeta -meta :extend :instance cljs.core/specify! cljs.core/clone cljs.core$macros/js-this Object :protocol-symbol :invalid-protocol-symbol :protocol :protocol-deprecated :deprecated :deprecation-nowarn :cljs.analyzer/namespaces :defs :impls :undeclared :undeclared-protocol-symbol cljs.core$macros/aset :hierarchy :default -prototype this-as self__ cljs.core$macros/this-as call apply .apply .-call .concat cljs.core$macros/array cljs.core/aclone :skip-protocol-flag cljs.core/IFn :methods :protocol-info :cljs.core$macros/not-found :protocol-invalid-method :fname :no-such-method :protocol-duped-method :invalid-arity :protocol-multiple-impls :extend-type-invalid-method-shape :method :extending-base-js-type :current-symbol :suggested-symbol :cljs.analyzer/type :cljs.analyzer/protocol-impl :cljs.analyzer/protocol-inline -> :factory :positional :internal-ctor :protocols deftype* .-getBasis .-cljs$lang$type .-cljs$lang$ctorStr .-cljs$lang$ctorPrWriter this__14083__auto__ writer__14084__auto__ opt__14085__auto__ cljs.core/-write __meta __extmap __hash :mutable -clone this__14098__auto__ -hash this__14099__auto__ cljs.core$macros/caching-hash hash-imap -equiv this__14100__auto__ other__14101__auto__ cljs.core$macros/identical? .-constructor cljs.core/equiv-map this__14102__auto__ this__14103__auto__ -lookup this__14104__auto__ k__14105__auto__ cljs.core/-lookup this__14106__auto__ else__14107__auto__ cljs.core$macros/case -count this__14108__auto__ cljs.core/count -conj this__14109__auto__ entry__14110__auto__ cljs.core/vector? cljs.core/-assoc cljs.core/-nth cljs.core/reduce cljs.core/-conj -assoc this__14111__auto__ k__14112__auto__ cljs.core$macros/condp cljs.core/keyword-identical? cljs.core/assoc -dissoc this__14113__auto__ k__14114__auto__ cljs.core/contains? cljs.core/dissoc cljs.core/with-meta cljs.core/into cljs.core/not-empty -seq this__14116__auto__ cljs.core/concat cljs.core$macros/vector IIterable -iterator RecordIter. cljs.core/-iterator -pr-writer this__14118__auto__ writer__14119__auto__ opts__14120__auto__ pr-pair__14121__auto__ keyval__14122__auto__ cljs.core/pr-sequential-writer cljs.core/pr-writer defrecord* map-> :map .-cljs$lang$ctorPrSeq this__14129__auto__ cljs.core/list writer__14130__auto__ :doc x__14139__auto__ m__14140__auto__ cljs.core$macros/aget goog/typeOf throw cljs.core/missing-protocol :jsdoc :protocol-with-variadic-method *unchecked-if* cljs.core$macros/coercive-not cljs.core/native-satisfies? cljs.core/LazySeq cljs.core/Delay try finally cljs.core$macros/with-redefs :>> js/Error. cljs.core/str p__14223__auto__ :line :const :nonchar case* cljs.core$macros/keyword? .-fqn cljs.core$macros/cond cljs.core/= :let :while :when cljs.core/rest iterys__14274__auto__ fs__14275__auto__ cljs.core/cons cljs.core$macros/lazy-seq cljs.core$macros/when-first cljs.core$macros/unchecked-inc cljs.core/chunk-append cljs.core/chunked-seq? c__14276__auto__ cljs.core/chunk-first :file :column :end-line :end-column cljs.core/not-native size__14277__auto__ cljs.core/chunk-buffer cljs.core$macros/coercive-boolean cljs.core/chunk-cons cljs.core/chunk cljs.core/chunk-rest iter__14278__auto__ not-native c__14444__auto__ js/Array. cljs.core/make-array dims__14461__auto__ cljs.core$macros/list dimarray__14462__auto__ cljs.core$macros/dotimes i__14463__auto__ cljs.core$macros/alength .-EMPTY cljs.core/List x__14476__auto__ cljs.core/PersistentVector cljs.core/PersistentVector. .-EMPTY-NODE .fromArray cljs.core/PersistentArrayMap cljs.core/PersistentArrayMap. cljs.core/PersistentHashMap .fromArrays cljs.core/PersistentHashSet cljs.core/PersistentHashSet. a__14550__auto__ a__14551__auto__ n__14552__auto__ cljs.core$macros/defonce method-table__14566__auto__ cljs.core/atom prefer-table__14567__auto__ method-cache__14568__auto__ cached-hierarchy__14569__auto__ hierarchy__14570__auto__ cljs.core/get-global-hierarchy cljs.core/MultiFn. cljs.core/symbol cljs.core/-add-method cljs.core/MultiFn start__14586__auto__ cljs.core/system-time ret__14587__auto__ cljs.core/prn .toFixed :print-fn println start__14588__auto__ .getTime js/Date. ret__14589__auto__ ___14590__auto__ end__14591__auto__ elapsed__14592__auto__ cljs.core$macros/str cljs.core/-first args cljs.core/-rest argc f apply-to cljs.core$macros/zero? sb__14612__auto__ js/goog.string.StringBuffer. cljs.core$macros/binding cljs.core/*print-newline* cljs.core/*print-fn* x__14613__auto__ .append .-prototype cljs.core/ITER_SYMBOL this__14627__auto__ cljs.core/es6-iterator var cljs.core$macros/js-delete cljs.core/-vreset! cljs.core/-deref js/goog nodeGlobalRequire cljs$core$IFn$_invoke$arity$variadic -cljs$lang$maxFixedArity -cljs$lang$applyTo len__14693__auto__ cljs.core$macros/js-arguments i__14694__auto__ .push :top-fn :variadic :max-fixed-arity :method-params :arglists :arglists-meta var_args args__14695__auto__ cljs.core$macros/copy-arguments argseq__14696__auto__ cljs.core/IndexedSeq .slice argseq__14712__auto__ :macro :def-emits-var &env -cljs$lang$macro]}, :doc nil}